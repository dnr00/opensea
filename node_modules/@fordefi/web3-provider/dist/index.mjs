// src/index.ts
import { EIP1193EventMap } from "viem";

// src/provider/provider.ts
import { EventEmitter } from "events";
import {
  http,
  InternalRpcError as InternalRpcError3,
  InvalidInputRpcError,
  InvalidParamsRpcError as InvalidParamsRpcError3,
  isAddressEqual as isAddressEqual2,
  isHex as isHex2,
  numberToHex,
  ProviderDisconnectedError,
  UnsupportedProviderMethodError
} from "viem";

// src/openapi/runtime.ts
var BASE_PATH = "http://localhost:8000".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  async request(context, initOverrides) {
    const { url, init } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && (response.status >= 200 && response.status < 300)) {
      return response;
    }
    throw new ResponseError(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    const init = {
      ...overriddenInit,
      body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
_BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
var BaseAPI = _BaseAPI;
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};

// src/openapi/models/ApiSignerRef.ts
function ApiSignerRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"],
    "state": json["state"]
  };
}

// src/openapi/models/UserRole.ts
function UserRoleFromJSON(json) {
  return UserRoleFromJSONTyped(json, false);
}
function UserRoleFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ApiUserRef.ts
function ApiUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"],
    "state": json["state"],
    "role": UserRoleFromJSON(json["role"])
  };
}

// src/openapi/models/EndUserRef.ts
function EndUserRefFromJSON(json) {
  return EndUserRefFromJSONTyped(json, false);
}
function EndUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "externalId": json["external_id"],
    "state": json["state"]
  };
}

// src/openapi/models/UserState.ts
function UserStateFromJSON(json) {
  return UserStateFromJSONTyped(json, false);
}
function UserStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/PersonRef.ts
function PersonRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "email": json["email"],
    "state": UserStateFromJSON(json["state"]),
    "role": UserRoleFromJSON(json["role"])
  };
}

// src/openapi/models/SystemUserRef.ts
function SystemUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"]
  };
}

// src/openapi/models/UserRef.ts
function UserRefFromJSON(json) {
  return UserRefFromJSONTyped(json, false);
}
function UserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_signer":
      return { ...ApiSignerRefFromJSONTyped(json, true), userType: "api_signer" };
    case "api_user":
      return { ...ApiUserRefFromJSONTyped(json, true), userType: "api_user" };
    case "end_user":
      return { ...EndUserRefFromJSONTyped(json, true), userType: "end_user" };
    case "person":
      return { ...PersonRefFromJSONTyped(json, true), userType: "person" };
    case "system":
      return { ...SystemUserRefFromJSONTyped(json, true), userType: "system" };
    default:
      throw new Error(`No variant of UserRef exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/ActionSigner.ts
function ActionSignerFromJSON(json) {
  return ActionSignerFromJSONTyped(json, false);
}
function ActionSignerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "user": UserRefFromJSON(json["user"]),
    "modifiedAt": new Date(json["modified_at"]),
    "hasSigned": json["has_signed"]
  };
}

// src/openapi/models/ActionSigningRequest.ts
function ActionSigningRequestFromJSON(json) {
  return ActionSigningRequestFromJSONTyped(json, false);
}
function ActionSigningRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signers": json["signers"].map(ActionSignerFromJSON)
  };
}

// src/openapi/models/AddEvmChainRequest.ts
function AddEvmChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "chain_id": value.chainId,
    "chain_name": value.chainName,
    "currency_symbol": value.currencySymbol,
    "is_testnet": value.isTestnet,
    "rpc_url": value.rpcUrl,
    "blockchain_explorer_url": value.blockchainExplorerUrl
  };
}

// src/openapi/models/AddChainRequest.ts
function AddChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["chainType"]) {
    case "evm":
      return AddEvmChainRequestToJSON(value);
    default:
      throw new Error(`No variant of AddChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/ApprovalDecision.ts
function ApprovalDecisionFromJSON(json) {
  return ApprovalDecisionFromJSONTyped(json, false);
}
function ApprovalDecisionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ApprovalState.ts
function ApprovalStateFromJSON(json) {
  return ApprovalStateFromJSONTyped(json, false);
}
function ApprovalStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/RequestApproverUser.ts
function RequestApproverUserFromJSON(json) {
  return RequestApproverUserFromJSONTyped(json, false);
}
function RequestApproverUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_user":
      return { ...ApiUserRefFromJSONTyped(json, true), userType: "api_user" };
    case "person":
      return { ...PersonRefFromJSONTyped(json, true), userType: "person" };
    default:
      throw new Error(`No variant of RequestApproverUser exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/RequestApprover.ts
function RequestApproverFromJSON(json) {
  return RequestApproverFromJSONTyped(json, false);
}
function RequestApproverFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "user": RequestApproverUserFromJSON(json["user"]),
    "modifiedAt": new Date(json["modified_at"]),
    "decision": ApprovalDecisionFromJSON(json["decision"]),
    "state": ApprovalStateFromJSON(json["state"])
  };
}

// src/openapi/models/ApprovalRequestGroup.ts
function ApprovalRequestGroupFromJSON(json) {
  return ApprovalRequestGroupFromJSONTyped(json, false);
}
function ApprovalRequestGroupFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "quorumSize": json["quorum_size"],
    "approvers": json["approvers"].map(RequestApproverFromJSON)
  };
}

// src/openapi/models/ApprovalRequestState.ts
function ApprovalRequestStateFromJSON(json) {
  return ApprovalRequestStateFromJSONTyped(json, false);
}
function ApprovalRequestStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ApprovalRequest.ts
function ApprovalRequestFromJSON(json) {
  return ApprovalRequestFromJSONTyped(json, false);
}
function ApprovalRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": ApprovalRequestStateFromJSON(json["state"]),
    "quorumSize": json["quorum_size"],
    "approvers": json["approvers"].map(RequestApproverFromJSON),
    "approvalGroups": !exists(json, "approval_groups") ? void 0 : json["approval_groups"].map(ApprovalRequestGroupFromJSON),
    "errorMessage": !exists(json, "error_message") ? void 0 : json["error_message"]
  };
}

// src/openapi/models/VaultState.ts
function VaultStateFromJSON(json) {
  return VaultStateFromJSONTyped(json, false);
}
function VaultStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/VaultRef.ts
function VaultRefFromJSON(json) {
  return VaultRefFromJSONTyped(json, false);
}
function VaultRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "address": !exists(json, "address") ? void 0 : json["address"],
    "state": VaultStateFromJSON(json["state"]),
    "endUser": !exists(json, "end_user") ? void 0 : EndUserRefFromJSON(json["end_user"])
  };
}

// src/openapi/models/AptosChainUniqueId.ts
function AptosChainUniqueIdFromJSON(json) {
  return AptosChainUniqueIdFromJSONTyped(json, false);
}
function AptosChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/BlockchainExplorer.ts
function BlockchainExplorerFromJSON(json) {
  return BlockchainExplorerFromJSONTyped(json, false);
}
function BlockchainExplorerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionUrl": json["transaction_url"],
    "addressUrl": json["address_url"],
    "rootUrl": json["root_url"],
    "transactionFormatUrl": json["transaction_format_url"],
    "addressFormatUrl": json["address_format_url"]
  };
}

// src/openapi/models/EnrichedAptosChain.ts
function EnrichedAptosChainFromJSON(json) {
  return EnrichedAptosChainFromJSONTyped(json, false);
}
function EnrichedAptosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": AptosChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"]
  };
}

// src/openapi/models/CosmosBech32Prefix.ts
function CosmosBech32PrefixFromJSON(json) {
  return CosmosBech32PrefixFromJSONTyped(json, false);
}
function CosmosBech32PrefixFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosChainUniqueId.ts
function CosmosChainUniqueIdFromJSON(json) {
  return CosmosChainUniqueIdFromJSONTyped(json, false);
}
function CosmosChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/EnrichedCosmosChain.ts
function EnrichedCosmosChainFromJSON(json) {
  return EnrichedCosmosChainFromJSONTyped(json, false);
}
function EnrichedCosmosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": CosmosChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "baseDenom": json["base_denom"],
    "bech32Prefix": CosmosBech32PrefixFromJSON(json["bech32_prefix"])
  };
}

// src/openapi/models/ChainSource.ts
function ChainSourceFromJSON(json) {
  return ChainSourceFromJSONTyped(json, false);
}
function ChainSourceFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmChainName.ts
function EvmChainNameFromJSON(json) {
  return EvmChainNameFromJSONTyped(json, false);
}
function EvmChainNameFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/GasType.ts
function GasTypeFromJSON(json) {
  return GasTypeFromJSONTyped(json, false);
}
function GasTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EnrichedEvmChain.ts
function EnrichedEvmChainFromJSON(json) {
  return EnrichedEvmChainFromJSONTyped(json, false);
}
function EnrichedEvmChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "namedChainId": !exists(json, "named_chain_id") ? void 0 : EvmChainNameFromJSON(json["named_chain_id"]),
    "chainId": json["chain_id"],
    "uniqueId": json["unique_id"],
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "gasType": GasTypeFromJSON(json["gas_type"]),
    "supportsSecureNode": !exists(json, "supports_secure_node") ? void 0 : json["supports_secure_node"],
    "rpcUrl": !exists(json, "rpc_url") ? void 0 : json["rpc_url"],
    "isTestnet": json["is_testnet"],
    "source": ChainSourceFromJSON(json["source"])
  };
}

// src/openapi/models/SolanaChainUniqueId.ts
function SolanaChainUniqueIdFromJSON(json) {
  return SolanaChainUniqueIdFromJSONTyped(json, false);
}
function SolanaChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/EnrichedSolanaChain.ts
function EnrichedSolanaChainFromJSON(json) {
  return EnrichedSolanaChainFromJSONTyped(json, false);
}
function EnrichedSolanaChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SolanaChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"]
  };
}

// src/openapi/models/SuiChainUniqueId.ts
function SuiChainUniqueIdFromJSON(json) {
  return SuiChainUniqueIdFromJSONTyped(json, false);
}
function SuiChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SuiChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/EnrichedSuiChain.ts
function EnrichedSuiChainFromJSON(json) {
  return EnrichedSuiChainFromJSONTyped(json, false);
}
function EnrichedSuiChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SuiChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"]
  };
}

// src/openapi/models/TonChainUniqueId.ts
function TonChainUniqueIdFromJSON(json) {
  return TonChainUniqueIdFromJSONTyped(json, false);
}
function TonChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/EnrichedTonChain.ts
function EnrichedTonChainFromJSON(json) {
  return EnrichedTonChainFromJSONTyped(json, false);
}
function EnrichedTonChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TonChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"]
  };
}

// src/openapi/models/UtxoChainUniqueId.ts
function UtxoChainUniqueIdFromJSON(json) {
  return UtxoChainUniqueIdFromJSONTyped(json, false);
}
function UtxoChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/EnrichedUtxoChain.ts
function EnrichedUtxoChainFromJSON(json) {
  return EnrichedUtxoChainFromJSONTyped(json, false);
}
function EnrichedUtxoChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": UtxoChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": !exists(json, "blockchain_explorer") ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"]
  };
}

// src/openapi/models/AptosChain.ts
function AptosChainFromJSON(json) {
  return AptosChainFromJSONTyped(json, false);
}
function AptosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": AptosChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/AptosAddressBookContactAddressRef.ts
function AptosAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(AptosChainFromJSON)
  };
}

// src/openapi/models/CosmosChain.ts
function CosmosChainFromJSON(json) {
  return CosmosChainFromJSONTyped(json, false);
}
function CosmosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": CosmosChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/CosmosAddressBookContactAddressRef.ts
function CosmosAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chain": CosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmChain.ts
function EvmChainFromJSON(json) {
  return EvmChainFromJSONTyped(json, false);
}
function EvmChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "namedChainId": !exists(json, "named_chain_id") ? void 0 : EvmChainNameFromJSON(json["named_chain_id"]),
    "chainId": json["chain_id"],
    "uniqueId": json["unique_id"]
  };
}

// src/openapi/models/EVMAddressBookContactAddressRef.ts
function EVMAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(EvmChainFromJSON)
  };
}

// src/openapi/models/SolanaChain.ts
function SolanaChainFromJSON(json) {
  return SolanaChainFromJSONTyped(json, false);
}
function SolanaChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SolanaChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/SolanaAddressBookContactAddressRef.ts
function SolanaAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(SolanaChainFromJSON)
  };
}

// src/openapi/models/SuiChain.ts
function SuiChainFromJSON(json) {
  return SuiChainFromJSONTyped(json, false);
}
function SuiChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SuiChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/SuiAddressBookContactAddressRef.ts
function SuiAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(SuiChainFromJSON)
  };
}

// src/openapi/models/TonChain.ts
function TonChainFromJSON(json) {
  return TonChainFromJSONTyped(json, false);
}
function TonChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TonChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/TonAddressBookContactAddressRef.ts
function TonAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(TonChainFromJSON)
  };
}

// src/openapi/models/UtxoChain.ts
function UtxoChainFromJSON(json) {
  return UtxoChainFromJSONTyped(json, false);
}
function UtxoChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": UtxoChainUniqueIdFromJSON(json["unique_id"])
  };
}
function UtxoChainToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "unique_id": UtxoChainUniqueIdToJSON(value.uniqueId)
  };
}

// src/openapi/models/UtxoAddressBookContactAddressRef.ts
function UtxoAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chain": UtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/ContactRefAddressRef.ts
function ContactRefAddressRefFromJSON(json) {
  return ContactRefAddressRefFromJSONTyped(json, false);
}
function ContactRefAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["chain_type"]) {
    case "aptos":
      return { ...AptosAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "aptos" };
    case "cosmos":
      return { ...CosmosAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "cosmos" };
    case "evm":
      return { ...EVMAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "evm" };
    case "solana":
      return { ...SolanaAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "solana" };
    case "sui":
      return { ...SuiAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "sui" };
    case "ton":
      return { ...TonAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "ton" };
    case "utxo":
      return { ...UtxoAddressBookContactAddressRefFromJSONTyped(json, true), chainType: "utxo" };
    default:
      throw new Error(`No variant of ContactRefAddressRef exists with 'chainType=${json["chainType"]}'`);
  }
}

// src/openapi/models/ContactRef.ts
function ContactRefFromJSON(json) {
  return ContactRefFromJSONTyped(json, false);
}
function ContactRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "addressRef": ContactRefAddressRefFromJSON(json["address_ref"])
  };
}

// src/openapi/models/Dapp.ts
function DappFromJSON(json) {
  return DappFromJSONTyped(json, false);
}
function DappFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "url": !exists(json, "url") ? void 0 : json["url"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/SolanaAddress.ts
function SolanaAddressFromJSON(json) {
  return SolanaAddressFromJSONTyped(json, false);
}
function SolanaAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": SolanaChainFromJSON(json["chain"]),
    "base58Repr": json["base58_repr"]
  };
}

// src/openapi/models/SplToken.ts
function SplTokenFromJSON(json) {
  return SplTokenFromJSONTyped(json, false);
}
function SplTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "address": SolanaAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/SolanaContractMetadata.ts
function SolanaContractMetadataFromJSON(json) {
  return SolanaContractMetadataFromJSONTyped(json, false);
}
function SolanaContractMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": !exists(json, "token") ? void 0 : SplTokenFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedSolanaAddress.ts
function EnrichedSolanaAddressFromJSON(json) {
  return EnrichedSolanaAddressFromJSONTyped(json, false);
}
function EnrichedSolanaAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"],
    "contract": !exists(json, "contract") ? void 0 : SolanaContractMetadataFromJSON(json["contract"])
  };
}

// src/openapi/models/AddressLookupTableState.ts
function AddressLookupTableStateFromJSON(json) {
  return AddressLookupTableStateFromJSONTyped(json, false);
}
function AddressLookupTableStateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "addresses": json["addresses"].map(EnrichedSolanaAddressFromJSON),
    "authority": !exists(json, "authority") ? void 0 : EnrichedSolanaAddressFromJSON(json["authority"]),
    "deactivationSlot": json["deactivation_slot"],
    "lastExtendedSlot": json["last_extended_slot"],
    "lastExtendedSlotStartIndex": json["last_extended_slot_start_index"]
  };
}

// src/openapi/models/EnrichedAptosAddress.ts
function EnrichedAptosAddressFromJSON(json) {
  return EnrichedAptosAddressFromJSONTyped(json, false);
}
function EnrichedAptosAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/CosmosKeyType.ts
function CosmosKeyTypeFromJSON(json) {
  return CosmosKeyTypeFromJSONTyped(json, false);
}
function CosmosKeyTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosKeyTypeToJSON(value) {
  return value;
}

// src/openapi/models/CosmosBechAddress.ts
function CosmosBechAddressFromJSON(json) {
  return CosmosBechAddressFromJSONTyped(json, false);
}
function CosmosBechAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"],
    "hexRepr": !exists(json, "hex_repr") ? void 0 : json["hex_repr"],
    "keyType": !exists(json, "key_type") ? void 0 : CosmosKeyTypeFromJSON(json["key_type"])
  };
}
function CosmosBechAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": CosmosChainUniqueIdToJSON(value.chain),
    "address": value.address,
    "hex_repr": value.hexRepr,
    "key_type": CosmosKeyTypeToJSON(value.keyType)
  };
}

// src/openapi/models/EnrichedCosmosBechAddress.ts
function EnrichedCosmosBechAddressFromJSON(json) {
  return EnrichedCosmosBechAddressFromJSONTyped(json, false);
}
function EnrichedCosmosBechAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": CosmosBechAddressFromJSON(json["address"])
  };
}

// src/openapi/models/EvmAddress.ts
function EvmAddressFromJSON(json) {
  return EvmAddressFromJSONTyped(json, false);
}
function EvmAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EvmChainFromJSON(json["chain"]),
    "hexRepr": json["hex_repr"]
  };
}

// src/openapi/models/Erc1155.ts
function Erc1155FromJSON(json) {
  return Erc1155FromJSONTyped(json, false);
}
function Erc1155FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"]
  };
}

// src/openapi/models/Erc20.ts
function Erc20FromJSON(json) {
  return Erc20FromJSONTyped(json, false);
}
function Erc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"],
    "decimals": json["decimals"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/Erc721.ts
function Erc721FromJSON(json) {
  return Erc721FromJSONTyped(json, false);
}
function Erc721FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"]
  };
}

// src/openapi/models/EvmContractMetadataToken.ts
function EvmContractMetadataTokenFromJSON(json) {
  return EvmContractMetadataTokenFromJSONTyped(json, false);
}
function EvmContractMetadataTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return { ...Erc1155FromJSONTyped(json, true), type: "erc1155" };
    case "erc20":
      return { ...Erc20FromJSONTyped(json, true), type: "erc20" };
    case "erc721":
      return { ...Erc721FromJSONTyped(json, true), type: "erc721" };
    default:
      throw new Error(`No variant of EvmContractMetadataToken exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmContractMetadata.ts
function EvmContractMetadataFromJSON(json) {
  return EvmContractMetadataFromJSONTyped(json, false);
}
function EvmContractMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": !exists(json, "token") ? void 0 : EvmContractMetadataTokenFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedEvmAddress.ts
function EnrichedEvmAddressFromJSON(json) {
  return EnrichedEvmAddressFromJSONTyped(json, false);
}
function EnrichedEvmAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"],
    "contract": !exists(json, "contract") ? void 0 : EvmContractMetadataFromJSON(json["contract"])
  };
}

// src/openapi/models/EnrichedSuiAddress.ts
function EnrichedSuiAddressFromJSON(json) {
  return EnrichedSuiAddressFromJSONTyped(json, false);
}
function EnrichedSuiAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedTonAddress.ts
function EnrichedTonAddressFromJSON(json) {
  return EnrichedTonAddressFromJSONTyped(json, false);
}
function EnrichedTonAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "rawAccount": json["raw_account"],
    "base64UrlBounceableAccount": json["base64_url_bounceable_account"],
    "base64UrlNonBounceableAccount": json["base64_url_non_bounceable_account"],
    "originalAccount": json["original_account"]
  };
}

// src/openapi/models/UtxoAddressType.ts
function UtxoAddressTypeFromJSON(json) {
  return UtxoAddressTypeFromJSONTyped(json, false);
}
function UtxoAddressTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoAddressTypeToJSON(value) {
  return value;
}

// src/openapi/models/UtxoAddress.ts
function UtxoAddressFromJSON(json) {
  return UtxoAddressFromJSONTyped(json, false);
}
function UtxoAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "addressType": UtxoAddressTypeFromJSON(json["address_type"]),
    "chain": UtxoChainFromJSON(json["chain"])
  };
}
function UtxoAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "address_type": UtxoAddressTypeToJSON(value.addressType),
    "chain": UtxoChainToJSON(value.chain)
  };
}

// src/openapi/models/VaultAddressRef.ts
function VaultAddressRefFromJSON(json) {
  return VaultAddressRefFromJSONTyped(json, false);
}
function VaultAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "vaultId": json["vault_id"],
    "name": json["name"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedUtxoAddress.ts
function EnrichedUtxoAddressFromJSON(json) {
  return EnrichedUtxoAddressFromJSONTyped(json, false);
}
function EnrichedUtxoAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "contact": !exists(json, "contact") ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": UtxoAddressFromJSON(json["address"]),
    "vaultAddress": !exists(json, "vault_address") ? void 0 : VaultAddressRefFromJSON(json["vault_address"])
  };
}

// src/openapi/models/EnrichedChain.ts
function EnrichedChainFromJSON(json) {
  return EnrichedChainFromJSONTyped(json, false);
}
function EnrichedChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["chain_type"]) {
    case "aptos":
      return { ...EnrichedAptosChainFromJSONTyped(json, true), chainType: "aptos" };
    case "cosmos":
      return { ...EnrichedCosmosChainFromJSONTyped(json, true), chainType: "cosmos" };
    case "evm":
      return { ...EnrichedEvmChainFromJSONTyped(json, true), chainType: "evm" };
    case "solana":
      return { ...EnrichedSolanaChainFromJSONTyped(json, true), chainType: "solana" };
    case "sui":
      return { ...EnrichedSuiChainFromJSONTyped(json, true), chainType: "sui" };
    case "ton":
      return { ...EnrichedTonChainFromJSONTyped(json, true), chainType: "ton" };
    case "utxo":
      return { ...EnrichedUtxoChainFromJSONTyped(json, true), chainType: "utxo" };
    default:
      throw new Error(`No variant of EnrichedChain exists with 'chainType=${json["chainType"]}'`);
  }
}

// src/openapi/models/CosmosAssetDetails.ts
function CosmosAssetDetailsFromJSON(json) {
  return CosmosAssetDetailsFromJSONTyped(json, false);
}
function CosmosAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/CosmosNativeCoin.ts
function CosmosNativeCoinFromJSON(json) {
  return CosmosNativeCoinFromJSONTyped(json, false);
}
function CosmosNativeCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "symbol": json["symbol"],
    "display": !exists(json, "display") ? void 0 : json["display"],
    "description": !exists(json, "description") ? void 0 : json["description"],
    "baseDenom": json["base_denom"],
    "denom": json["denom"],
    "decimals": json["decimals"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedCosmosNativeAssetIdentifier.ts
function EnrichedCosmosNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": CosmosNativeCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosToken.ts
function CosmosTokenFromJSON(json) {
  return CosmosTokenFromJSONTyped(json, false);
}
function CosmosTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "symbol": json["symbol"],
    "display": !exists(json, "display") ? void 0 : json["display"],
    "description": !exists(json, "description") ? void 0 : json["description"],
    "baseDenom": json["base_denom"],
    "denom": json["denom"],
    "decimals": json["decimals"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedCosmosTokenAssetIdentifier.ts
function EnrichedCosmosTokenAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/EnrichedCosmosAssetIdentifierDetails.ts
function EnrichedCosmosAssetIdentifierDetailsFromJSON(json) {
  return EnrichedCosmosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedCosmosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return { ...EnrichedCosmosNativeAssetIdentifierFromJSONTyped(json, true), type: "native" };
    case "token":
      return { ...EnrichedCosmosTokenAssetIdentifierFromJSONTyped(json, true), type: "token" };
    default:
      throw new Error(`No variant of EnrichedCosmosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedCosmosAssetIdentifier.ts
function EnrichedCosmosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedCosmosAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedEvmErc1155AssetIdentifier.ts
function EnrichedEvmErc1155AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EnrichedEvmErc20AssetIdentifier.ts
function EnrichedEvmErc20AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedEvmErc721AssetIdentifier.ts
function EnrichedEvmErc721AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EnrichedEvmNativeAssetIdentifier.ts
function EnrichedEvmNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedEvmAssetIdentifierDetails.ts
function EnrichedEvmAssetIdentifierDetailsFromJSON(json) {
  return EnrichedEvmAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedEvmAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return { ...EnrichedEvmErc1155AssetIdentifierFromJSONTyped(json, true), type: "erc1155" };
    case "erc20":
      return { ...EnrichedEvmErc20AssetIdentifierFromJSONTyped(json, true), type: "erc20" };
    case "erc721":
      return { ...EnrichedEvmErc721AssetIdentifierFromJSONTyped(json, true), type: "erc721" };
    case "native":
      return { ...EnrichedEvmNativeAssetIdentifierFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of EnrichedEvmAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedEvmAssetIdentifier.ts
function EnrichedEvmAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedEvmAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedSolanaNativeAssetIdentifier.ts
function EnrichedSolanaNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedSolanaSplTokenAssetIdentifier.ts
function EnrichedSolanaSplTokenAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedSolanaAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedSolanaAssetIdentifierDetails.ts
function EnrichedSolanaAssetIdentifierDetailsFromJSON(json) {
  return EnrichedSolanaAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedSolanaAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return { ...EnrichedSolanaNativeAssetIdentifierFromJSONTyped(json, true), type: "native" };
    case "spl_token":
      return { ...EnrichedSolanaSplTokenAssetIdentifierFromJSONTyped(json, true), type: "spl_token" };
    default:
      throw new Error(`No variant of EnrichedSolanaAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedSolanaAssetIdentifier.ts
function EnrichedSolanaAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedSolanaAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedSuiCoin.ts
function EnrichedSuiCoinFromJSON(json) {
  return EnrichedSuiCoinFromJSONTyped(json, false);
}
function EnrichedSuiCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": json["coin_type"],
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/EnrichedSuiCoinAssetIdentifier.ts
function EnrichedSuiCoinAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": EnrichedSuiCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/EnrichedSuiNativeAssetIdentifier.ts
function EnrichedSuiNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedSuiAssetIdentifierDetails.ts
function EnrichedSuiAssetIdentifierDetailsFromJSON(json) {
  return EnrichedSuiAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedSuiAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return { ...EnrichedSuiCoinAssetIdentifierFromJSONTyped(json, true), type: "coin" };
    case "native":
      return { ...EnrichedSuiNativeAssetIdentifierFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of EnrichedSuiAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedSuiAssetIdentifier.ts
function EnrichedSuiAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedSuiAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedUtxoNativeAssetIdentifier.ts
function EnrichedUtxoNativeAssetIdentifierFromJSON(json) {
  return EnrichedUtxoNativeAssetIdentifierFromJSONTyped(json, false);
}
function EnrichedUtxoNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedUtxoAssetIdentifier.ts
function EnrichedUtxoAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedUtxoNativeAssetIdentifierFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedAssetIdentifier.ts
function EnrichedAssetIdentifierFromJSON(json) {
  return EnrichedAssetIdentifierFromJSONTyped(json, false);
}
function EnrichedAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "cosmos":
      return { ...EnrichedCosmosAssetIdentifierFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EnrichedEvmAssetIdentifierFromJSONTyped(json, true), type: "evm" };
    case "solana":
      return { ...EnrichedSolanaAssetIdentifierFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...EnrichedSuiAssetIdentifierFromJSONTyped(json, true), type: "sui" };
    case "utxo":
      return { ...EnrichedUtxoAssetIdentifierFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of EnrichedAssetIdentifier exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/FiatCurrencySymbol.ts
function FiatCurrencySymbolFromJSON(json) {
  return FiatCurrencySymbolFromJSONTyped(json, false);
}
function FiatCurrencySymbolFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/FiatCurrency.ts
function FiatCurrencyFromJSON(json) {
  return FiatCurrencyFromJSONTyped(json, false);
}
function FiatCurrencyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "currencySymbol": FiatCurrencySymbolFromJSON(json["currency_symbol"]),
    "decimals": json["decimals"]
  };
}

// src/openapi/models/Price.ts
function PriceFromJSON(json) {
  return PriceFromJSONTyped(json, false);
}
function PriceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "price": json["price"],
    "priceFloat": json["price_float"],
    "fiatCurrency": FiatCurrencyFromJSON(json["fiat_currency"])
  };
}

// src/openapi/models/CosmosAsset.ts
function CosmosAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": CosmosAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EvmErc1155Asset.ts
function EvmErc1155AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EvmErc20Asset.ts
function EvmErc20AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EvmErc721Asset.ts
function EvmErc721AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EvmNativeAsset.ts
function EvmNativeAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EvmAssetDetails.ts
function EvmAssetDetailsFromJSON(json) {
  return EvmAssetDetailsFromJSONTyped(json, false);
}
function EvmAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "evm_erc1155_asset":
      return { ...EvmErc1155AssetFromJSONTyped(json, true), type: "evm_erc1155_asset" };
    case "evm_erc20_asset":
      return { ...EvmErc20AssetFromJSONTyped(json, true), type: "evm_erc20_asset" };
    case "evm_erc721_asset":
      return { ...EvmErc721AssetFromJSONTyped(json, true), type: "evm_erc721_asset" };
    case "evm_native_asset":
      return { ...EvmNativeAssetFromJSONTyped(json, true), type: "evm_native_asset" };
    default:
      throw new Error(`No variant of EvmAssetDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmAsset.ts
function EvmAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": EvmAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/SolanaAssetDetails.ts
function SolanaAssetDetailsFromJSON(json) {
  return SolanaAssetDetailsFromJSONTyped(json, false);
}
function SolanaAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/SolanaAsset.ts
function SolanaAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": SolanaAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/SuiAssetDetails.ts
function SuiAssetDetailsFromJSON(json) {
  return SuiAssetDetailsFromJSONTyped(json, false);
}
function SuiAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/SuiAsset.ts
function SuiAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": SuiAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/UtxoNativeAsset.ts
function UtxoNativeAssetFromJSON(json) {
  return UtxoNativeAssetFromJSONTyped(json, false);
}
function UtxoNativeAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/UtxoAsset.ts
function UtxoAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": UtxoNativeAssetFromJSON(json["details"])
  };
}

// src/openapi/models/Asset.ts
function AssetFromJSON(json) {
  return AssetFromJSONTyped(json, false);
}
function AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "cosmos_asset":
      return { ...CosmosAssetFromJSONTyped(json, true), type: "cosmos_asset" };
    case "evm_asset":
      return { ...EvmAssetFromJSONTyped(json, true), type: "evm_asset" };
    case "solana_asset":
      return { ...SolanaAssetFromJSONTyped(json, true), type: "solana_asset" };
    case "sui_asset":
      return { ...SuiAssetFromJSONTyped(json, true), type: "sui_asset" };
    case "utxo_asset":
      return { ...UtxoAssetFromJSONTyped(json, true), type: "utxo_asset" };
    default:
      throw new Error(`No variant of Asset exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/Balances.ts
function BalancesFromJSON(json) {
  return BalancesFromJSONTyped(json, false);
}
function BalancesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mined": json["mined"],
    "pendingIncoming": json["pending_incoming"]
  };
}

// src/openapi/models/AptosCoinTypeRequest.ts
function AptosCoinTypeRequestFromJSON(json) {
  return AptosCoinTypeRequestFromJSONTyped(json, false);
}
function AptosCoinTypeRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": AptosChainUniqueIdFromJSON(json["chain"]),
    "coinTypeStr": json["coin_type_str"]
  };
}
function AptosCoinTypeRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": AptosChainUniqueIdToJSON(value.chain),
    "coin_type_str": value.coinTypeStr
  };
}

// src/openapi/models/AptosCoinAssetIdentifierRequest.ts
function AptosCoinAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": AptosCoinTypeRequestFromJSON(json["coin_type"])
  };
}
function AptosCoinAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "coin_type": AptosCoinTypeRequestToJSON(value.coinType)
  };
}

// src/openapi/models/AptosNativeAssetIdentifierRequest.ts
function AptosNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": AptosChainUniqueIdFromJSON(json["chain"])
  };
}
function AptosNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": AptosChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/AptosAssetIdentifierDetails.ts
function AptosAssetIdentifierDetailsFromJSON(json) {
  return AptosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function AptosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return { ...AptosCoinAssetIdentifierRequestFromJSONTyped(json, true), type: "coin" };
    case "native":
      return { ...AptosNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of AptosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function AptosAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "coin":
      return AptosCoinAssetIdentifierRequestToJSON(value);
    case "native":
      return AptosNativeAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of AptosAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/AptosAssetIdentifier.ts
function AptosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": AptosAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/CosmosNativeAssetIdentifierRequest.ts
function CosmosNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": CosmosChainUniqueIdFromJSON(json["chain"])
  };
}
function CosmosNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": CosmosChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/CosmosTokenAssetIdentifierRequest.ts
function CosmosTokenAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "denom": json["denom"]
  };
}
function CosmosTokenAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": CosmosChainUniqueIdToJSON(value.chain),
    "denom": value.denom
  };
}

// src/openapi/models/CosmosAssetIdentifierDetails.ts
function CosmosAssetIdentifierDetailsFromJSON(json) {
  return CosmosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function CosmosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return { ...CosmosNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    case "token":
      return { ...CosmosTokenAssetIdentifierRequestFromJSONTyped(json, true), type: "token" };
    default:
      throw new Error(`No variant of CosmosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function CosmosAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "native":
      return CosmosNativeAssetIdentifierRequestToJSON(value);
    case "token":
      return CosmosTokenAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of CosmosAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CosmosAssetIdentifier.ts
function CosmosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": CosmosAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmAddressRequest.ts
function EvmAddressRequestFromJSON(json) {
  return EvmAddressRequestFromJSONTyped(json, false);
}
function EvmAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": json["chain"],
    "hexRepr": json["hex_repr"]
  };
}
function EvmAddressRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": value.chain,
    "hex_repr": value.hexRepr
  };
}

// src/openapi/models/EvmErc1155AssetIdentifierRequest.ts
function EvmErc1155AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}
function EvmErc1155AssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "token": EvmAddressRequestToJSON(value.token),
    "token_id": value.tokenId
  };
}

// src/openapi/models/EvmErc20AssetIdentifierRequest.ts
function EvmErc20AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"])
  };
}
function EvmErc20AssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "token": EvmAddressRequestToJSON(value.token)
  };
}

// src/openapi/models/EvmErc721AssetIdentifierRequest.ts
function EvmErc721AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}
function EvmErc721AssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "token": EvmAddressRequestToJSON(value.token),
    "token_id": value.tokenId
  };
}

// src/openapi/models/EvmNativeAssetIdentifierRequest.ts
function EvmNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": json["chain"]
  };
}
function EvmNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": value.chain
  };
}

// src/openapi/models/EvmAssetIdentifierDetails.ts
function EvmAssetIdentifierDetailsFromJSON(json) {
  return EvmAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EvmAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return { ...EvmErc1155AssetIdentifierRequestFromJSONTyped(json, true), type: "erc1155" };
    case "erc20":
      return { ...EvmErc20AssetIdentifierRequestFromJSONTyped(json, true), type: "erc20" };
    case "erc721":
      return { ...EvmErc721AssetIdentifierRequestFromJSONTyped(json, true), type: "erc721" };
    case "native":
      return { ...EvmNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of EvmAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function EvmAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "erc1155":
      return EvmErc1155AssetIdentifierRequestToJSON(value);
    case "erc20":
      return EvmErc20AssetIdentifierRequestToJSON(value);
    case "erc721":
      return EvmErc721AssetIdentifierRequestToJSON(value);
    case "native":
      return EvmNativeAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of EvmAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/EvmAssetIdentifier.ts
function EvmAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EvmAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SolanaNativeAssetIdentifierRequest.ts
function SolanaNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": SolanaChainUniqueIdFromJSON(json["chain"])
  };
}
function SolanaNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": SolanaChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/SolanaAddressRequest.ts
function SolanaAddressRequestFromJSON(json) {
  return SolanaAddressRequestFromJSONTyped(json, false);
}
function SolanaAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": SolanaChainUniqueIdFromJSON(json["chain"]),
    "base58Repr": json["base58_repr"]
  };
}
function SolanaAddressRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": SolanaChainUniqueIdToJSON(value.chain),
    "base58_repr": value.base58Repr
  };
}

// src/openapi/models/SolanaSplTokenAssetIdentifierRequest.ts
function SolanaSplTokenAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": SolanaAddressRequestFromJSON(json["token"])
  };
}
function SolanaSplTokenAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "token": SolanaAddressRequestToJSON(value.token)
  };
}

// src/openapi/models/SolanaAssetIdentifierDetails.ts
function SolanaAssetIdentifierDetailsFromJSON(json) {
  return SolanaAssetIdentifierDetailsFromJSONTyped(json, false);
}
function SolanaAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return { ...SolanaNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    case "spl_token":
      return { ...SolanaSplTokenAssetIdentifierRequestFromJSONTyped(json, true), type: "spl_token" };
    default:
      throw new Error(`No variant of SolanaAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function SolanaAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "native":
      return SolanaNativeAssetIdentifierRequestToJSON(value);
    case "spl_token":
      return SolanaSplTokenAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of SolanaAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SolanaAssetIdentifier.ts
function SolanaAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SolanaAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SuiCoinTypeRequest.ts
function SuiCoinTypeRequestFromJSON(json) {
  return SuiCoinTypeRequestFromJSONTyped(json, false);
}
function SuiCoinTypeRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": SuiChainUniqueIdFromJSON(json["chain"]),
    "coinTypeStr": json["coin_type_str"]
  };
}
function SuiCoinTypeRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": SuiChainUniqueIdToJSON(value.chain),
    "coin_type_str": value.coinTypeStr
  };
}

// src/openapi/models/SuiCoinAssetIdentifierRequest.ts
function SuiCoinAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": SuiCoinTypeRequestFromJSON(json["coin_type"])
  };
}
function SuiCoinAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "coin_type": SuiCoinTypeRequestToJSON(value.coinType)
  };
}

// src/openapi/models/SuiNativeAssetIdentifierRequest.ts
function SuiNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": SuiChainUniqueIdFromJSON(json["chain"])
  };
}
function SuiNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": SuiChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/SuiAssetIdentifierDetails.ts
function SuiAssetIdentifierDetailsFromJSON(json) {
  return SuiAssetIdentifierDetailsFromJSONTyped(json, false);
}
function SuiAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return { ...SuiCoinAssetIdentifierRequestFromJSONTyped(json, true), type: "coin" };
    case "native":
      return { ...SuiNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of SuiAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function SuiAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "coin":
      return SuiCoinAssetIdentifierRequestToJSON(value);
    case "native":
      return SuiNativeAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of SuiAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiAssetIdentifier.ts
function SuiAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SuiAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"])
  };
}

// src/openapi/models/TonAddressRequest.ts
function TonAddressRequestFromJSON(json) {
  return TonAddressRequestFromJSONTyped(json, false);
}
function TonAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": TonChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"]
  };
}
function TonAddressRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": TonChainUniqueIdToJSON(value.chain),
    "address": value.address
  };
}

// src/openapi/models/TonJettonAssetIdentifierRequest.ts
function TonJettonAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "jetton": TonAddressRequestFromJSON(json["jetton"])
  };
}
function TonJettonAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "jetton": TonAddressRequestToJSON(value.jetton)
  };
}

// src/openapi/models/TonNativeAssetIdentifierRequest.ts
function TonNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": TonChainUniqueIdFromJSON(json["chain"])
  };
}
function TonNativeAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": TonChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/TonAssetIdentifierDetails.ts
function TonAssetIdentifierDetailsFromJSON(json) {
  return TonAssetIdentifierDetailsFromJSONTyped(json, false);
}
function TonAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "jetton":
      return { ...TonJettonAssetIdentifierRequestFromJSONTyped(json, true), type: "jetton" };
    case "native":
      return { ...TonNativeAssetIdentifierRequestFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of TonAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function TonAssetIdentifierDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "jetton":
      return TonJettonAssetIdentifierRequestToJSON(value);
    case "native":
      return TonNativeAssetIdentifierRequestToJSON(value);
    default:
      throw new Error(`No variant of TonAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TonAssetIdentifier.ts
function TonAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": TonAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedTonChainFromJSON(json["chain"])
  };
}

// src/openapi/models/UtxoNativeAssetIdentifierRequest.ts
function UtxoNativeAssetIdentifierRequestFromJSON(json) {
  return UtxoNativeAssetIdentifierRequestFromJSONTyped(json, false);
}
function UtxoNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": UtxoChainUniqueIdFromJSON(json["chain"])
  };
}

// src/openapi/models/UtxoAssetIdentifier.ts
function UtxoAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": UtxoNativeAssetIdentifierRequestFromJSON(json["details"]),
    "chain": EnrichedUtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/AssetIdentifier.ts
function AssetIdentifierFromJSON(json) {
  return AssetIdentifierFromJSONTyped(json, false);
}
function AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return { ...AptosAssetIdentifierFromJSONTyped(json, true), type: "aptos" };
    case "cosmos":
      return { ...CosmosAssetIdentifierFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EvmAssetIdentifierFromJSONTyped(json, true), type: "evm" };
    case "solana":
      return { ...SolanaAssetIdentifierFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...SuiAssetIdentifierFromJSONTyped(json, true), type: "sui" };
    case "ton":
      return { ...TonAssetIdentifierFromJSONTyped(json, true), type: "ton" };
    case "utxo":
      return { ...UtxoAssetIdentifierFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of AssetIdentifier exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AssetInfo.ts
function AssetInfoFromJSON(json) {
  return AssetInfoFromJSONTyped(json, false);
}
function AssetInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "assetIdentifier": AssetIdentifierFromJSON(json["asset_identifier"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "verified": json["verified"],
    "metadataUri": !exists(json, "metadata_uri") ? void 0 : json["metadata_uri"],
    "isSpam": json["is_spam"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/PricedAsset.ts
function PricedAssetFromJSON(json) {
  return PricedAssetFromJSONTyped(json, false);
}
function PricedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "assetIdentifier": !exists(json, "asset_identifier") ? void 0 : EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "assetInfo": AssetInfoFromJSON(json["asset_info"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/OwnedAsset.ts
function OwnedAssetFromJSON(json) {
  return OwnedAssetFromJSONTyped(json, false);
}
function OwnedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "asset": !exists(json, "asset") ? void 0 : AssetFromJSON(json["asset"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "balance": json["balance"],
    "balances": BalancesFromJSON(json["balances"])
  };
}

// src/openapi/models/AllowanceDetails.ts
function AllowanceDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "spender": EnrichedEvmAddressFromJSON(json["spender"])
  };
}

// src/openapi/models/Erc1155Contract.ts
function Erc1155ContractFromJSON(json) {
  return Erc1155ContractFromJSONTyped(json, false);
}
function Erc1155ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc1155FromJSON(json["token"])
  };
}

// src/openapi/models/Erc1155AllowanceForAllChange.ts
function Erc1155AllowanceForAllChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "approved": json["approved"],
    "tokenContract": Erc1155ContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/Erc20Contract.ts
function Erc20ContractFromJSON(json) {
  return Erc20ContractFromJSONTyped(json, false);
}
function Erc20ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc20FromJSON(json["token"])
  };
}

// src/openapi/models/Erc20AllowanceChange.ts
function Erc20AllowanceChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "amount": json["amount"],
    "tokenContract": Erc20ContractFromJSON(json["token_contract"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/Erc721Contract.ts
function Erc721ContractFromJSON(json) {
  return Erc721ContractFromJSONTyped(json, false);
}
function Erc721ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc721FromJSON(json["token"])
  };
}

// src/openapi/models/Erc721AllowanceChange.ts
function Erc721AllowanceChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "tokenId": json["token_id"],
    "tokenContract": Erc721ContractFromJSON(json["token_contract"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/Erc721AllowanceForAllChange.ts
function Erc721AllowanceForAllChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "approved": json["approved"],
    "tokenContract": Erc721ContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/AllowanceEffect.ts
function AllowanceEffectFromJSON(json) {
  return AllowanceEffectFromJSONTyped(json, false);
}
function AllowanceEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155_for_all":
      return { ...Erc1155AllowanceForAllChangeFromJSONTyped(json, true), type: "erc1155_for_all" };
    case "erc20":
      return { ...Erc20AllowanceChangeFromJSONTyped(json, true), type: "erc20" };
    case "erc721":
      return { ...Erc721AllowanceChangeFromJSONTyped(json, true), type: "erc721" };
    case "erc721_for_all":
      return { ...Erc721AllowanceForAllChangeFromJSONTyped(json, true), type: "erc721_for_all" };
    default:
      throw new Error(`No variant of AllowanceEffect exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AminoMessage.ts
function AminoMessageFromJSON(json) {
  return AminoMessageFromJSONTyped(json, false);
}
function AminoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function AminoMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/AminoMessagesList.ts
function AminoMessagesListFromJSON(json) {
  return AminoMessagesListFromJSONTyped(json, false);
}
function AminoMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"].map(AminoMessageFromJSON)
  };
}

// src/openapi/models/StdCoin.ts
function StdCoinToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "denom": value.denom,
    "amount": value.amount
  };
}

// src/openapi/models/StdFeeRequest.ts
function StdFeeRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount.map(StdCoinToJSON),
    "gas": value.gas,
    "payer": value.payer,
    "granter": value.granter,
    "fee_payer": value.feePayer
  };
}

// src/openapi/models/AminoRequestData.ts
function AminoRequestDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "format": value.format,
    "messages": value.messages.map(AminoMessageToJSON),
    "memo": value.memo,
    "std_fee": StdFeeRequestToJSON(value.stdFee),
    "timeout_height": value.timeoutHeight
  };
}

// src/openapi/models/CosmosNativeCoinWithAmount.ts
function CosmosNativeCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "type": json["type"],
    "coin": CosmosNativeCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosTokenWithAmount.ts
function CosmosTokenWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "type": json["type"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosCoinWithAmountCoinWithAmount.ts
function CosmosCoinWithAmountCoinWithAmountFromJSON(json) {
  return CosmosCoinWithAmountCoinWithAmountFromJSONTyped(json, false);
}
function CosmosCoinWithAmountCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return { ...CosmosNativeCoinWithAmountFromJSONTyped(json, true), type: "native" };
    case "token":
      return { ...CosmosTokenWithAmountFromJSONTyped(json, true), type: "token" };
    default:
      throw new Error(`No variant of CosmosCoinWithAmountCoinWithAmount exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/CosmosCoinWithAmount.ts
function CosmosCoinWithAmountFromJSON(json) {
  return CosmosCoinWithAmountFromJSONTyped(json, false);
}
function CosmosCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "coinWithAmount": CosmosCoinWithAmountCoinWithAmountFromJSON(json["coin_with_amount"])
  };
}

// src/openapi/models/StdFee.ts
function StdFeeFromJSON(json) {
  return StdFeeFromJSONTyped(json, false);
}
function StdFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "coins": json["coins"].map(CosmosCoinWithAmountFromJSON),
    "gas": json["gas"],
    "payer": !exists(json, "payer") ? void 0 : EnrichedCosmosBechAddressFromJSON(json["payer"]),
    "granter": !exists(json, "granter") ? void 0 : EnrichedCosmosBechAddressFromJSON(json["granter"]),
    "feePayer": !exists(json, "fee_payer") ? void 0 : EnrichedCosmosBechAddressFromJSON(json["fee_payer"])
  };
}

// src/openapi/models/StdSignDoc.ts
function StdSignDocFromJSON(json) {
  return StdSignDocFromJSONTyped(json, false);
}
function StdSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "accountNumber": json["account_number"],
    "sequence": json["sequence"],
    "timeoutHeight": !exists(json, "timeout_height") ? void 0 : json["timeout_height"],
    "fee": StdFeeFromJSON(json["fee"]),
    "messages": AminoMessagesListFromJSON(json["messages"]),
    "memo": json["memo"]
  };
}

// src/openapi/models/AminoSignDoc.ts
function AminoSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "signDoc": StdSignDocFromJSON(json["sign_doc"])
  };
}

// src/openapi/models/AptosAccountRepr.ts
function AptosAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "hex_repr": value.hexRepr
  };
}

// src/openapi/models/AptosAssetIdentifierRequest.ts
function AptosAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": AptosAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/AptosBalanceChangeEffectType.ts
function AptosBalanceChangeEffectTypeFromJSON(json) {
  return AptosBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function AptosBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosBalanceChangeEffect.ts
function AptosBalanceChangeEffectFromJSON(json) {
  return AptosBalanceChangeEffectFromJSONTyped(json, false);
}
function AptosBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": AptosBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedAptosAddressFromJSON(json["address"]),
    "owner": !exists(json, "owner") ? void 0 : EnrichedAptosAddressFromJSON(json["owner"])
  };
}

// src/openapi/models/AptosBlock.ts
function AptosBlockFromJSON(json) {
  return AptosBlockFromJSONTyped(json, false);
}
function AptosBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "height": json["height"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/AptosCoinTransferDetails.ts
function AptosCoinTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/AptosCustomGasPriceRequest.ts
function AptosCustomGasPriceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "price": value.price
  };
}

// src/openapi/models/AptosTransferEffectType.ts
function AptosTransferEffectTypeFromJSON(json) {
  return AptosTransferEffectTypeFromJSONTyped(json, false);
}
function AptosTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosTransferEffect.ts
function AptosTransferEffectFromJSON(json) {
  return AptosTransferEffectFromJSONTyped(json, false);
}
function AptosTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": AptosTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedAptosAddressFromJSON(json["from"]),
    "to": EnrichedAptosAddressFromJSON(json["to"])
  };
}

// src/openapi/models/AptosEffects.ts
function AptosEffectsFromJSON(json) {
  return AptosEffectsFromJSONTyped(json, false);
}
function AptosEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(AptosBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(AptosTransferEffectFromJSON)
  };
}

// src/openapi/models/AptosEntryFunctionPayload.ts
function AptosEntryFunctionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "typedArguments": json["typed_arguments"],
    "arguments": json["arguments"],
    "type": json["type"],
    "functionId": json["function_id"],
    "address": EnrichedAptosAddressFromJSON(json["address"]),
    "module": json["module"],
    "functionName": json["function_name"]
  };
}

// src/openapi/models/AptosEntryPointDetails.ts
function AptosEntryPointDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"])
  };
}

// src/openapi/models/AptosFeeStatement.ts
function AptosFeeStatementFromJSON(json) {
  return AptosFeeStatementFromJSONTyped(json, false);
}
function AptosFeeStatementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "executionGasUnits": json["execution_gas_units"],
    "ioGasUnits": json["io_gas_units"],
    "storageFeeOctas": json["storage_fee_octas"],
    "storageFeeRefundOctas": json["storage_fee_refund_octas"],
    "totalChargeGasUnits": json["total_charge_gas_units"],
    "totalGas": json["total_gas"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/FeePriority.ts
function FeePriorityFromJSON(json) {
  return FeePriorityFromJSONTyped(json, false);
}
function FeePriorityFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function FeePriorityToJSON(value) {
  return value;
}

// src/openapi/models/AptosPriorityGasPriceRequest.ts
function AptosPriorityGasPriceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "priority": FeePriorityToJSON(value.priority)
  };
}

// src/openapi/models/AptosGasConfigRequestPrice.ts
function AptosGasConfigRequestPriceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "custom":
      return AptosCustomGasPriceRequestToJSON(value);
    case "priority":
      return AptosPriorityGasPriceRequestToJSON(value);
    default:
      throw new Error(`No variant of AptosGasConfigRequestPrice exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/AptosGasConfigRequest.ts
function AptosGasConfigRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "max_gas": value.maxGas,
    "price": AptosGasConfigRequestPriceToJSON(value.price)
  };
}

// src/openapi/models/AptosGasPrice.ts
function AptosGasPriceFromJSON(json) {
  return AptosGasPriceFromJSONTyped(json, false);
}
function AptosGasPriceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "priorityLevel": FeePriorityFromJSON(json["priority_level"]),
    "price": json["price"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/AptosGasData.ts
function AptosGasDataFromJSON(json) {
  return AptosGasDataFromJSONTyped(json, false);
}
function AptosGasDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "gasLimit": json["gas_limit"],
    "price": AptosGasPriceFromJSON(json["price"])
  };
}

// src/openapi/models/AptosMessageState.ts
function AptosMessageStateFromJSON(json) {
  return AptosMessageStateFromJSONTyped(json, false);
}
function AptosMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/StateChangeReason.ts
function StateChangeReasonFromJSON(json) {
  return StateChangeReasonFromJSONTyped(json, false);
}
function StateChangeReasonFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosMessageStateChange.ts
function AptosMessageStateChangeFromJSON(json) {
  return AptosMessageStateChangeFromJSONTyped(json, false);
}
function AptosMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : AptosMessageStateFromJSON(json["previous_state"]),
    "newState": AptosMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/AptosMessageType.ts
function AptosMessageTypeFromJSON(json) {
  return AptosMessageTypeFromJSONTyped(json, false);
}
function AptosMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/BatchData.ts
function BatchDataFromJSON(json) {
  return BatchDataFromJSONTyped(json, false);
}
function BatchDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "batchId": json["batch_id"],
    "indexInBatch": json["index_in_batch"],
    "batchSize": json["batch_size"]
  };
}

// src/openapi/models/TransactionPolicyMatchActionType.ts
function TransactionPolicyMatchActionTypeFromJSON(json) {
  return TransactionPolicyMatchActionTypeFromJSONTyped(json, false);
}
function TransactionPolicyMatchActionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/PolicyMatch.ts
function PolicyMatchFromJSON(json) {
  return PolicyMatchFromJSONTyped(json, false);
}
function PolicyMatchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isDefault": json["is_default"],
    "ruleId": json["rule_id"],
    "ruleName": json["rule_name"],
    "actionType": TransactionPolicyMatchActionTypeFromJSON(json["action_type"])
  };
}

// src/openapi/models/PushMode.ts
var PushMode = {
  auto: "auto",
  manual: "manual",
  deferred: "deferred"
};
function PushModeFromJSON(json) {
  return PushModeFromJSONTyped(json, false);
}
function PushModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PushModeToJSON(value) {
  return value;
}

// src/openapi/models/SignMode.ts
function SignModeFromJSON(json) {
  return SignModeFromJSONTyped(json, false);
}
function SignModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SignModeToJSON(value) {
  return value;
}

// src/openapi/models/SignerType.ts
var SignerType = {
  initiator: "initiator",
  apiSigner: "api_signer",
  endUser: "end_user",
  multipleSigners: "multiple_signers"
};
function SignerTypeFromJSON(json) {
  return SignerTypeFromJSONTyped(json, false);
}
function SignerTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SignerTypeToJSON(value) {
  return value;
}

// src/openapi/models/TransactionRiskSeverity.ts
function TransactionRiskSeverityFromJSON(json) {
  return TransactionRiskSeverityFromJSONTyped(json, false);
}
function TransactionRiskSeverityFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionRiskType.ts
function TransactionRiskTypeFromJSON(json) {
  return TransactionRiskTypeFromJSONTyped(json, false);
}
function TransactionRiskTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionRisk.ts
function TransactionRiskFromJSON(json) {
  return TransactionRiskFromJSONTyped(json, false);
}
function TransactionRiskFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": TransactionRiskTypeFromJSON(json["type"]),
    "severity": TransactionRiskSeverityFromJSON(json["severity"]),
    "title": json["title"],
    "description": json["description"]
  };
}

// src/openapi/models/ManagedTransactionData.ts
function ManagedTransactionDataFromJSON(json) {
  return ManagedTransactionDataFromJSONTyped(json, false);
}
function ManagedTransactionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "createdBy": UserRefFromJSON(json["created_by"]),
    "abortedBy": !exists(json, "aborted_by") ? void 0 : UserRefFromJSON(json["aborted_by"]),
    "deviceSigningRequest": !exists(json, "device_signing_request") ? void 0 : ActionSigningRequestFromJSON(json["device_signing_request"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "policyMatch": !exists(json, "policy_match") ? void 0 : PolicyMatchFromJSON(json["policy_match"]),
    "signerType": SignerTypeFromJSON(json["signer_type"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "errorPushingToBlockchainMessage": !exists(json, "error_pushing_to_blockchain_message") ? void 0 : json["error_pushing_to_blockchain_message"],
    "originalErrorPushingToBlockchainMessage": !exists(json, "original_error_pushing_to_blockchain_message") ? void 0 : json["original_error_pushing_to_blockchain_message"],
    "vault": VaultRefFromJSON(json["vault"]),
    "idempotenceId": !exists(json, "idempotence_id") ? void 0 : json["idempotence_id"],
    "hasCurrentUserVaultPermissions": json["has_current_user_vault_permissions"],
    "batchData": !exists(json, "batch_data") ? void 0 : BatchDataFromJSON(json["batch_data"]),
    "pushMode": !exists(json, "push_mode") ? void 0 : PushModeFromJSON(json["push_mode"]),
    "lastPushedAt": !exists(json, "last_pushed_at") ? void 0 : new Date(json["last_pushed_at"]),
    "signMode": !exists(json, "sign_mode") ? void 0 : SignModeFromJSON(json["sign_mode"])
  };
}

// src/openapi/models/SignatureSignedBy.ts
function SignatureSignedByFromJSON(json) {
  return SignatureSignedByFromJSONTyped(json, false);
}
function SignatureSignedByFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_signer":
      return { ...ApiSignerRefFromJSONTyped(json, true), userType: "api_signer" };
    case "end_user":
      return { ...EndUserRefFromJSONTyped(json, true), userType: "end_user" };
    case "person":
      return { ...PersonRefFromJSONTyped(json, true), userType: "person" };
    default:
      throw new Error(`No variant of SignatureSignedBy exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/Signature.ts
function SignatureFromJSON(json) {
  return SignatureFromJSONTyped(json, false);
}
function SignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"],
    "signedBy": !exists(json, "signed_by") ? void 0 : SignatureSignedByFromJSON(json["signed_by"])
  };
}

// src/openapi/models/TransactionDirection.ts
function TransactionDirectionFromJSON(json) {
  return TransactionDirectionFromJSONTyped(json, false);
}
function TransactionDirectionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionSpamState.ts
function TransactionSpamStateFromJSON(json) {
  return TransactionSpamStateFromJSONTyped(json, false);
}
function TransactionSpamStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosMessage.ts
function AptosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "aptosMessageType": AptosMessageTypeFromJSON(json["aptos_message_type"]),
    "state": AptosMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(AptosMessageStateChangeFromJSON),
    "rawOriginalMessageToSign": json["raw_original_message_to_sign"],
    "stringOriginalMessageToSign": json["string_original_message_to_sign"],
    "rawFullMessageToSign": json["raw_full_message_to_sign"],
    "stringFullMessageToSign": json["string_full_message_to_sign"],
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/AptosNativeTransferDetails.ts
function AptosNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/AptosPersonalMessageRequest.ts
function AptosPersonalMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "should_include_address": value.shouldIncludeAddress,
    "application": value.application,
    "should_include_application": value.shouldIncludeApplication,
    "chain": AptosChainUniqueIdToJSON(value.chain),
    "should_include_chain": value.shouldIncludeChain,
    "message_to_sign": value.messageToSign,
    "nonce": value.nonce
  };
}

// src/openapi/models/AptosRecipientHex.ts
function AptosRecipientHexToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": value.address
  };
}

// src/openapi/models/AptosRecipientVaultId.ts
function AptosRecipientVaultIdToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_id": value.vaultId
  };
}

// src/openapi/models/AptosReversionState.ts
function AptosReversionStateFromJSON(json) {
  return AptosReversionStateFromJSONTyped(json, false);
}
function AptosReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosReversion.ts
function AptosReversionFromJSON(json) {
  return AptosReversionFromJSONTyped(json, false);
}
function AptosReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": AptosReversionStateFromJSON(json["state"]),
    "reason": !exists(json, "reason") ? void 0 : json["reason"]
  };
}

// src/openapi/models/AptosScriptDetails.ts
function AptosScriptDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/AptosSuggestedFees.ts
function AptosSuggestedFeesFromJSON(json) {
  return AptosSuggestedFeesFromJSONTyped(json, false);
}
function AptosSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"],
    "chainUniqueId": AptosChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/AptosTransactionAptosTransactionTypeDetails.ts
function AptosTransactionAptosTransactionTypeDetailsFromJSON(json) {
  return AptosTransactionAptosTransactionTypeDetailsFromJSONTyped(json, false);
}
function AptosTransactionAptosTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "coin_transfer":
      return { ...AptosCoinTransferDetailsFromJSONTyped(json, true), type: "coin_transfer" };
    case "entry_point":
      return { ...AptosEntryPointDetailsFromJSONTyped(json, true), type: "entry_point" };
    case "native_transfer":
      return { ...AptosNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "script":
      return { ...AptosScriptDetailsFromJSONTyped(json, true), type: "script" };
    default:
      throw new Error(`No variant of AptosTransactionAptosTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/ScriptPayload.ts
function ScriptPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "typedArguments": json["typed_arguments"],
    "arguments": json["arguments"],
    "type": json["type"],
    "code": json["code"]
  };
}

// src/openapi/models/AptosTransactionPayload.ts
function AptosTransactionPayloadFromJSON(json) {
  return AptosTransactionPayloadFromJSONTyped(json, false);
}
function AptosTransactionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "entry_point":
      return { ...AptosEntryFunctionPayloadFromJSONTyped(json, true), type: "entry_point" };
    case "script":
      return { ...ScriptPayloadFromJSONTyped(json, true), type: "script" };
    default:
      throw new Error(`No variant of AptosTransactionPayload exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AptosTransactionResult.ts
function AptosTransactionResultFromJSON(json) {
  return AptosTransactionResultFromJSONTyped(json, false);
}
function AptosTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reversion": AptosReversionFromJSON(json["reversion"]),
    "feeStatement": AptosFeeStatementFromJSON(json["fee_statement"]),
    "effects": AptosEffectsFromJSON(json["effects"]),
    "rawResult": !exists(json, "raw_result") ? void 0 : json["raw_result"]
  };
}

// src/openapi/models/AptosTransactionState.ts
function AptosTransactionStateFromJSON(json) {
  return AptosTransactionStateFromJSONTyped(json, false);
}
function AptosTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/AptosTransactionStateChange.ts
function AptosTransactionStateChangeFromJSON(json) {
  return AptosTransactionStateChangeFromJSONTyped(json, false);
}
function AptosTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : AptosTransactionStateFromJSON(json["previous_state"]),
    "newState": AptosTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/SimulationStatus.ts
function SimulationStatusFromJSON(json) {
  return SimulationStatusFromJSONTyped(json, false);
}
function SimulationStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SimulationStatusResult.ts
function SimulationStatusResultFromJSON(json) {
  return SimulationStatusResultFromJSONTyped(json, false);
}
function SimulationStatusResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "simulationStatus": !exists(json, "simulation_status") ? void 0 : SimulationStatusFromJSON(json["simulation_status"]),
    "details": json["details"]
  };
}

// src/openapi/models/AptosTransaction.ts
function AptosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "aptosTransactionTypeDetails": AptosTransactionAptosTransactionTypeDetailsFromJSON(json["aptos_transaction_type_details"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "state": AptosTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(AptosTransactionStateChangeFromJSON),
    "version": !exists(json, "version") ? void 0 : json["version"],
    "nonce": !exists(json, "nonce") ? void 0 : json["nonce"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "payload": AptosTransactionPayloadFromJSON(json["payload"]),
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "block": !exists(json, "block") ? void 0 : AptosBlockFromJSON(json["block"]),
    "gasSubmitted": AptosGasDataFromJSON(json["gas_submitted"]),
    "serializedSignedTransaction": !exists(json, "serialized_signed_transaction") ? void 0 : json["serialized_signed_transaction"],
    "expectedResult": !exists(json, "expected_result") ? void 0 : AptosTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": !exists(json, "simulation_status_result") ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : AptosTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/AptosVaultMetadataValue.ts
function AptosVaultMetadataValueFromJSON(json) {
  return AptosVaultMetadataValueFromJSONTyped(json, false);
}
function AptosVaultMetadataValueFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosVaultMetadataValueToJSON(value) {
  return value;
}

// src/openapi/models/PendingVaultGroupActionAdd.ts
function PendingVaultGroupActionAddFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "vaultGroupId": json["vault_group_id"],
    "vaultGroupName": json["vault_group_name"]
  };
}

// src/openapi/models/PendingVaultGroupActionRemove.ts
function PendingVaultGroupActionRemoveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/AptosVaultPendingVaultGroupAction.ts
function AptosVaultPendingVaultGroupActionFromJSON(json) {
  return AptosVaultPendingVaultGroupActionFromJSONTyped(json, false);
}
function AptosVaultPendingVaultGroupActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "add":
      return { ...PendingVaultGroupActionAddFromJSONTyped(json, true), type: "add" };
    case "remove":
      return { ...PendingVaultGroupActionRemoveFromJSONTyped(json, true), type: "remove" };
    default:
      throw new Error(`No variant of AptosVaultPendingVaultGroupAction exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/KeysetScope.ts
function KeysetScopeFromJSON(json) {
  return KeysetScopeFromJSONTyped(json, false);
}
function KeysetScopeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/KeysetRef.ts
function KeysetRefFromJSON(json) {
  return KeysetRefFromJSONTyped(json, false);
}
function KeysetRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "scope": KeysetScopeFromJSON(json["scope"])
  };
}

// src/openapi/models/MasterPublicKey.ts
function MasterPublicKeyFromJSON(json) {
  return MasterPublicKeyFromJSONTyped(json, false);
}
function MasterPublicKeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "xpub": json["xpub"]
  };
}

// src/openapi/models/VaultDerivationInfo.ts
function VaultDerivationInfoFromJSON(json) {
  return VaultDerivationInfoFromJSONTyped(json, false);
}
function VaultDerivationInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "derivationPath": json["derivation_path"],
    "masterPublicKey": MasterPublicKeyFromJSON(json["master_public_key"])
  };
}

// src/openapi/models/VaultGroupRef.ts
function VaultGroupRefFromJSON(json) {
  return VaultGroupRefFromJSONTyped(json, false);
}
function VaultGroupRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "vaultCount": json["vault_count"],
    "canCurrentUserCreateOrEditVaults": json["can_current_user_create_or_edit_vaults"]
  };
}

// src/openapi/models/AptosVault.ts
function AptosVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/CosmosAssetIdentifierRequest.ts
function CosmosAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": CosmosAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/EvmAssetIdentifierRequest.ts
function EvmAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": EvmAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/SolanaAssetIdentifierRequest.ts
function SolanaAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": SolanaAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/SuiAssetIdentifierRequest.ts
function SuiAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": SuiAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/TonAssetIdentifierRequest.ts
function TonAssetIdentifierRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": TonAssetIdentifierDetailsToJSON(value.details)
  };
}

// src/openapi/models/SuiPureBoolInput.ts
function SuiPureBoolInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureBoolInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/SuiPureByteArrayInput.ts
function SuiPureByteArrayInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureByteArrayInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/SuiPureNumberInput.ts
function SuiPureNumberInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureNumberInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/SuiPureStringInput.ts
function SuiPureStringInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureStringInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/BaseSuiPureInputValue.ts
function BaseSuiPureInputValueFromJSON(json) {
  return BaseSuiPureInputValueFromJSONTyped(json, false);
}
function BaseSuiPureInputValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "bool_pure_input":
      return { ...SuiPureBoolInputFromJSONTyped(json, true), type: "bool_pure_input" };
    case "byte_array_pure_input":
      return { ...SuiPureByteArrayInputFromJSONTyped(json, true), type: "byte_array_pure_input" };
    case "number_pure_input":
      return { ...SuiPureNumberInputFromJSONTyped(json, true), type: "number_pure_input" };
    case "string_pure_input":
      return { ...SuiPureStringInputFromJSONTyped(json, true), type: "string_pure_input" };
    default:
      throw new Error(`No variant of BaseSuiPureInputValue exists with 'type=${json["type"]}'`);
  }
}
function BaseSuiPureInputValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "bool_pure_input":
      return SuiPureBoolInputToJSON(value);
    case "byte_array_pure_input":
      return SuiPureByteArrayInputToJSON(value);
    case "number_pure_input":
      return SuiPureNumberInputToJSON(value);
    case "string_pure_input":
      return SuiPureStringInputToJSON(value);
    default:
      throw new Error(`No variant of BaseSuiPureInputValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/BaseSuiPureInput.ts
function BaseSuiPureInputFromJSON(json) {
  return BaseSuiPureInputFromJSONTyped(json, false);
}
function BaseSuiPureInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "value": BaseSuiPureInputValueFromJSON(json["value"])
  };
}
function BaseSuiPureInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "value": BaseSuiPureInputValueToJSON(value.value)
  };
}

// src/openapi/models/SolanaCompiledInstructionRequest.ts
function SolanaCompiledInstructionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "program_index": value.programIndex,
    "data": value.data,
    "account_indexes": value.accountIndexes
  };
}

// src/openapi/models/SolanaMessageAddressTableLookupRequest.ts
function SolanaMessageAddressTableLookupRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "account_key": value.accountKey,
    "writable_indexes": value.writableIndexes,
    "readonly_indexes": value.readonlyIndexes
  };
}

// src/openapi/models/SolanaMessageVersion.ts
function SolanaMessageVersionFromJSON(json) {
  return SolanaMessageVersionFromJSONTyped(json, false);
}
function SolanaMessageVersionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaMessageVersionToJSON(value) {
  return value;
}

// src/openapi/models/SolanaTransactionAccountRequest.ts
function SolanaTransactionAccountRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "writable": value.writable,
    "signer": value.signer,
    "ephemeral_key": value.ephemeralKey
  };
}

// src/openapi/models/SolanaTransactionSignaturesRequest.ts
function SolanaTransactionSignaturesRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}

// src/openapi/models/BinaryHashPayload.ts
function BinaryHashPayloadToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "format": value.format,
    "hash_binary": value.hashBinary
  };
}

// src/openapi/models/EcdsaSignature.ts
function EcdsaSignatureFromJSON(json) {
  return EcdsaSignatureFromJSONTyped(json, false);
}
function EcdsaSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "r": json["r"],
    "s": json["s"],
    "v": json["v"]
  };
}

// src/openapi/models/BlackBoxSignatureEcdsaSecp256k1Details.ts
function BlackBoxSignatureEcdsaSecp256k1DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": !exists(json, "signature") ? void 0 : EcdsaSignatureFromJSON(json["signature"]),
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureEcdsaStarkDetails.ts
function BlackBoxSignatureEcdsaStarkDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": !exists(json, "signature") ? void 0 : EcdsaSignatureFromJSON(json["signature"]),
    "hashBinary": json["hash_binary"],
    "hashInteger": json["hash_integer"]
  };
}

// src/openapi/models/BlackBoxSignatureEddsaEd25519Details.ts
function BlackBoxSignatureEddsaEd25519DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": !exists(json, "signature") ? void 0 : json["signature"],
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureSchnorrSecp256k1Details.ts
function BlackBoxSignatureSchnorrSecp256k1DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": !exists(json, "signature") ? void 0 : json["signature"],
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureDetails.ts
function BlackBoxSignatureDetailsFromJSON(json) {
  return BlackBoxSignatureDetailsFromJSONTyped(json, false);
}
function BlackBoxSignatureDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "ecdsa_secp256k1":
      return { ...BlackBoxSignatureEcdsaSecp256k1DetailsFromJSONTyped(json, true), type: "ecdsa_secp256k1" };
    case "ecdsa_stark":
      return { ...BlackBoxSignatureEcdsaStarkDetailsFromJSONTyped(json, true), type: "ecdsa_stark" };
    case "eddsa_ed25519":
      return { ...BlackBoxSignatureEddsaEd25519DetailsFromJSONTyped(json, true), type: "eddsa_ed25519" };
    case "schnorr_secp256k1":
      return { ...BlackBoxSignatureSchnorrSecp256k1DetailsFromJSONTyped(json, true), type: "schnorr_secp256k1" };
    default:
      throw new Error(`No variant of BlackBoxSignatureDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/BlackBoxSignatureState.ts
function BlackBoxSignatureStateFromJSON(json) {
  return BlackBoxSignatureStateFromJSONTyped(json, false);
}
function BlackBoxSignatureStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function BlackBoxSignatureStateToJSON(value) {
  return value;
}

// src/openapi/models/BlackBoxSignatureStateChange.ts
function BlackBoxSignatureStateChangeFromJSON(json) {
  return BlackBoxSignatureStateChangeFromJSONTyped(json, false);
}
function BlackBoxSignatureStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : BlackBoxSignatureStateFromJSON(json["previous_state"]),
    "newState": BlackBoxSignatureStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/BlackBoxSignature.ts
function BlackBoxSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "state": BlackBoxSignatureStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(BlackBoxSignatureStateChangeFromJSON),
    "payload": json["payload"],
    "vault": VaultRefFromJSON(json["vault"]),
    "details": BlackBoxSignatureDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EcdsaSecp256k1BlackBoxVault.ts
function EcdsaSecp256k1BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/EcdsaStarkBlackBoxVault.ts
function EcdsaStarkBlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "publicKey": json["public_key"],
    "starkKey": json["stark_key"]
  };
}

// src/openapi/models/EddsaED25519BlackBoxVault.ts
function EddsaED25519BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/SchnorrSecp256k1BlackBoxValue.ts
function SchnorrSecp256k1BlackBoxValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/BlackBoxVaultDetails.ts
function BlackBoxVaultDetailsFromJSON(json) {
  return BlackBoxVaultDetailsFromJSONTyped(json, false);
}
function BlackBoxVaultDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "ecdsa_secp256k1":
      return { ...EcdsaSecp256k1BlackBoxVaultFromJSONTyped(json, true), type: "ecdsa_secp256k1" };
    case "ecdsa_stark":
      return { ...EcdsaStarkBlackBoxVaultFromJSONTyped(json, true), type: "ecdsa_stark" };
    case "eddsa_ed25519":
      return { ...EddsaED25519BlackBoxVaultFromJSONTyped(json, true), type: "eddsa_ed25519" };
    case "schnorr_secp256k1":
      return { ...SchnorrSecp256k1BlackBoxValueFromJSONTyped(json, true), type: "schnorr_secp256k1" };
    default:
      throw new Error(`No variant of BlackBoxVaultDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/BlackBoxVault.ts
function BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "details": BlackBoxVaultDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EvmBridgeEffectKnownDestination.ts
function EvmBridgeEffectKnownDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "destAddress": EnrichedEvmAddressFromJSON(json["dest_address"]),
    "destChain": EnrichedEvmChainFromJSON(json["dest_chain"])
  };
}

// src/openapi/models/EvmBridgeEffectUnknownDestination.ts
function EvmBridgeEffectUnknownDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "destAddress": !exists(json, "dest_address") ? void 0 : json["dest_address"],
    "destChain": json["dest_chain"]
  };
}

// src/openapi/models/EvmBridgeEffectDestination.ts
function EvmBridgeEffectDestinationFromJSON(json) {
  return EvmBridgeEffectDestinationFromJSONTyped(json, false);
}
function EvmBridgeEffectDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "known_target_chain":
      return { ...EvmBridgeEffectKnownDestinationFromJSONTyped(json, true), type: "known_target_chain" };
    case "unknown_target_chain":
      return { ...EvmBridgeEffectUnknownDestinationFromJSONTyped(json, true), type: "unknown_target_chain" };
    default:
      throw new Error(`No variant of EvmBridgeEffectDestination exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmBridgeEffectSourceErc20.ts
function EvmBridgeEffectSourceErc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "sourceAddress": EnrichedEvmAddressFromJSON(json["source_address"]),
    "token": Erc20FromJSON(json["token"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/EvmBridgeEffectSourceNative.ts
function EvmBridgeEffectSourceNativeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "sourceAddress": EnrichedEvmAddressFromJSON(json["source_address"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/EvmBridgeEffectSource.ts
function EvmBridgeEffectSourceFromJSON(json) {
  return EvmBridgeEffectSourceFromJSONTyped(json, false);
}
function EvmBridgeEffectSourceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "erc20":
      return { ...EvmBridgeEffectSourceErc20FromJSONTyped(json, true), type: "erc20" };
    case "native":
      return { ...EvmBridgeEffectSourceNativeFromJSONTyped(json, true), type: "native" };
    default:
      throw new Error(`No variant of EvmBridgeEffectSource exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmBridgeEffect.ts
function EvmBridgeEffectFromJSON(json) {
  return EvmBridgeEffectFromJSONTyped(json, false);
}
function EvmBridgeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "bridgeName": json["bridge_name"],
    "source": !exists(json, "source") ? void 0 : EvmBridgeEffectSourceFromJSON(json["source"]),
    "destination": EvmBridgeEffectDestinationFromJSON(json["destination"]),
    "amount": json["amount"]
  };
}

// src/openapi/models/BridgeDetails.ts
function BridgeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "bridgeEffect": EvmBridgeEffectFromJSON(json["bridge_effect"])
  };
}

// src/openapi/models/ChainType.ts
var ChainType = {
  aptos: "aptos",
  cosmos: "cosmos",
  evm: "evm",
  solana: "solana",
  sui: "sui",
  ton: "ton",
  utxo: "utxo"
};

// src/openapi/models/FiatValue.ts
function FiatValueFromJSON(json) {
  return FiatValueFromJSONTyped(json, false);
}
function FiatValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "value": json["value"],
    "currency": FiatCurrencyFromJSON(json["currency"])
  };
}

// src/openapi/models/ChainWithAssets.ts
function ChainWithAssetsFromJSON(json) {
  return ChainWithAssetsFromJSONTyped(json, false);
}
function ChainWithAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": EnrichedChainFromJSON(json["chain"]),
    "nativeAsset": OwnedAssetFromJSON(json["native_asset"]),
    "totalValue": FiatValueFromJSON(json["total_value"])
  };
}

// src/openapi/models/TimestampedSignature.ts
function TimestampedSignatureFromJSON(json) {
  return TimestampedSignatureFromJSONTyped(json, false);
}
function TimestampedSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signature": json["signature"],
    "timestamp": json["timestamp"]
  };
}

// src/openapi/models/ContractCallDetails.ts
function ContractCallDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/ContractDeploymentDetails.ts
function ContractDeploymentDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "contractAddress": EnrichedEvmAddressFromJSON(json["contract_address"])
  };
}

// src/openapi/models/CosmosAccountRepr.ts
function CosmosAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "bech32_repr": value.bech32Repr
  };
}

// src/openapi/models/CosmosMessageBase64Data.ts
function CosmosMessageBase64DataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "data": json["data"]
  };
}
function CosmosMessageBase64DataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "data": value.data
  };
}

// src/openapi/models/CosmosMessageStrData.ts
function CosmosMessageStrDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "data": json["data"]
  };
}
function CosmosMessageStrDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "data": value.data
  };
}

// src/openapi/models/CosmosMessageData.ts
function CosmosMessageDataFromJSON(json) {
  return CosmosMessageDataFromJSONTyped(json, false);
}
function CosmosMessageDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "base64":
      return { ...CosmosMessageBase64DataFromJSONTyped(json, true), type: "base64" };
    case "string":
      return { ...CosmosMessageStrDataFromJSONTyped(json, true), type: "string" };
    default:
      throw new Error(`No variant of CosmosMessageData exists with 'type=${json["type"]}'`);
  }
}
function CosmosMessageDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "base64":
      return CosmosMessageBase64DataToJSON(value);
    case "string":
      return CosmosMessageStrDataToJSON(value);
    default:
      throw new Error(`No variant of CosmosMessageData exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CosmosArbitraryMessageRequest.ts
function CosmosArbitraryMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": CosmosChainUniqueIdToJSON(value.chain),
    "data": CosmosMessageDataToJSON(value.data)
  };
}

// src/openapi/models/CosmosBalanceChangeEffectCoinInfo.ts
function CosmosBalanceChangeEffectCoinInfoFromJSON(json) {
  return CosmosBalanceChangeEffectCoinInfoFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectCoinInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isVerified": json["is_verified"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosBalanceChangeEffectType.ts
function CosmosBalanceChangeEffectTypeFromJSON(json) {
  return CosmosBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosBalanceChangeEffect.ts
function CosmosBalanceChangeEffectFromJSON(json) {
  return CosmosBalanceChangeEffectFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": CosmosBalanceChangeEffectTypeFromJSON(json["type"]),
    "coinInfo": CosmosBalanceChangeEffectCoinInfoFromJSON(json["coin_info"]),
    "address": EnrichedCosmosBechAddressFromJSON(json["address"]),
    "owner": !exists(json, "owner") ? void 0 : EnrichedCosmosBechAddressFromJSON(json["owner"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/CosmosBechAddressEnrichedChain.ts
function CosmosBechAddressEnrichedChainFromJSON(json) {
  return CosmosBechAddressEnrichedChainFromJSONTyped(json, false);
}
function CosmosBechAddressEnrichedChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"],
    "hexRepr": !exists(json, "hex_repr") ? void 0 : json["hex_repr"],
    "keyType": !exists(json, "key_type") ? void 0 : CosmosKeyTypeFromJSON(json["key_type"]),
    "enrichedChain": EnrichedCosmosChainFromJSON(json["enriched_chain"])
  };
}

// src/openapi/models/CosmosTransferEffectType.ts
function CosmosTransferEffectTypeFromJSON(json) {
  return CosmosTransferEffectTypeFromJSONTyped(json, false);
}
function CosmosTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosTransferEffect.ts
function CosmosTransferEffectFromJSON(json) {
  return CosmosTransferEffectFromJSONTyped(json, false);
}
function CosmosTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": CosmosTransferEffectTypeFromJSON(json["type"]),
    "coinInfo": CosmosBalanceChangeEffectCoinInfoFromJSON(json["coin_info"]),
    "from": EnrichedCosmosBechAddressFromJSON(json["from"]),
    "to": EnrichedCosmosBechAddressFromJSON(json["to"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/CosmosEffects.ts
function CosmosEffectsFromJSON(json) {
  return CosmosEffectsFromJSONTyped(json, false);
}
function CosmosEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(CosmosBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(CosmosTransferEffectFromJSON)
  };
}

// src/openapi/models/CosmosGasDebit.ts
function CosmosGasDebitFromJSON(json) {
  return CosmosGasDebitFromJSONTyped(json, false);
}
function CosmosGasDebitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "gasUsed": json["gas_used"],
    "totalFee": json["total_fee"].map(CosmosCoinWithAmountFromJSON),
    "fiatPrices": json["fiat_prices"].map(PriceFromJSON)
  };
}

// src/openapi/models/CosmosMessageState.ts
function CosmosMessageStateFromJSON(json) {
  return CosmosMessageStateFromJSONTyped(json, false);
}
function CosmosMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/CosmosMessageStateChange.ts
function CosmosMessageStateChangeFromJSON(json) {
  return CosmosMessageStateChangeFromJSONTyped(json, false);
}
function CosmosMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : CosmosMessageStateFromJSON(json["previous_state"]),
    "newState": CosmosMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/CosmosMessageType.ts
function CosmosMessageTypeFromJSON(json) {
  return CosmosMessageTypeFromJSONTyped(json, false);
}
function CosmosMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosMessage.ts
function CosmosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "cosmosMessageType": CosmosMessageTypeFromJSON(json["cosmos_message_type"]),
    "state": CosmosMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(CosmosMessageStateChangeFromJSON),
    "data": CosmosMessageDataFromJSON(json["data"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/DirectMessage.ts
function DirectMessageFromJSON(json) {
  return DirectMessageFromJSONTyped(json, false);
}
function DirectMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}

// src/openapi/models/DirectMessagesList.ts
function DirectMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"].map(DirectMessageFromJSON)
  };
}

// src/openapi/models/MinedMessagesList.ts
function MinedMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"]
  };
}

// src/openapi/models/MessagesList.ts
function MessagesListFromJSON(json) {
  return MessagesListFromJSONTyped(json, false);
}
function MessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["format"]) {
    case "amino":
      return { ...AminoMessagesListFromJSONTyped(json, true), format: "amino" };
    case "direct":
      return { ...DirectMessagesListFromJSONTyped(json, true), format: "direct" };
    case "mined":
      return { ...MinedMessagesListFromJSONTyped(json, true), format: "mined" };
    default:
      throw new Error(`No variant of MessagesList exists with 'format=${json["format"]}'`);
  }
}

// src/openapi/models/CosmosMultipleMessagesTransactionDetails.ts
function CosmosMultipleMessagesTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "type": json["type"]
  };
}

// src/openapi/models/TransferDirection.ts
function TransferDirectionFromJSON(json) {
  return TransferDirectionFromJSONTyped(json, false);
}
function TransferDirectionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosNativeTransferDetails.ts
function CosmosNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "recipient": EnrichedCosmosBechAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"],
    "type": json["type"]
  };
}

// src/openapi/models/CosmosPushData.ts
function CosmosPushDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "transaction_body": value.transactionBody
  };
}

// src/openapi/models/CosmosSuggestedFees.ts
function CosmosSuggestedFeesFromJSON(json) {
  return CosmosSuggestedFeesFromJSONTyped(json, false);
}
function CosmosSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": CosmosChainUniqueIdFromJSON(json["chain_unique_id"]),
    "feePerSignature": !exists(json, "fee_per_signature") ? void 0 : json["fee_per_signature"]
  };
}

// src/openapi/models/CosmosTokenTransferDetails.ts
function CosmosTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "recipient": EnrichedCosmosBechAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"],
    "type": json["type"]
  };
}

// src/openapi/models/CosmosTransactionResult.ts
function CosmosTransactionResultFromJSON(json) {
  return CosmosTransactionResultFromJSONTyped(json, false);
}
function CosmosTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "message": !exists(json, "message") ? void 0 : json["message"],
    "gasDebit": CosmosGasDebitFromJSON(json["gas_debit"]),
    "effects": CosmosEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/CosmosTransactionState.ts
function CosmosTransactionStateFromJSON(json) {
  return CosmosTransactionStateFromJSONTyped(json, false);
}
function CosmosTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/CosmosTransactionStateChange.ts
function CosmosTransactionStateChangeFromJSON(json) {
  return CosmosTransactionStateChangeFromJSONTyped(json, false);
}
function CosmosTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : CosmosTransactionStateFromJSON(json["previous_state"]),
    "newState": CosmosTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/CosmosTransactionTypeDetails.ts
function CosmosTransactionTypeDetailsFromJSON(json) {
  return CosmosTransactionTypeDetailsFromJSONTyped(json, false);
}
function CosmosTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "messages":
      return { ...CosmosMultipleMessagesTransactionDetailsFromJSONTyped(json, true), type: "messages" };
    case "native_transfer":
      return { ...CosmosNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "token_transfer":
      return { ...CosmosTokenTransferDetailsFromJSONTyped(json, true), type: "token_transfer" };
    default:
      throw new Error(`No variant of CosmosTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/DirectSignDoc.ts
function DirectSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "body": json["body"],
    "authInfo": json["auth_info"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "accountNumber": json["account_number"],
    "signedBody": json["signed_body"],
    "signedAuthInfo": json["signed_auth_info"]
  };
}

// src/openapi/models/MinedSignDoc.ts
function MinedSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SignDoc.ts
function SignDocFromJSON(json) {
  return SignDocFromJSONTyped(json, false);
}
function SignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["format"]) {
    case "amino":
      return { ...AminoSignDocFromJSONTyped(json, true), format: "amino" };
    case "direct":
      return { ...DirectSignDocFromJSONTyped(json, true), format: "direct" };
    case "mined":
      return { ...MinedSignDocFromJSONTyped(json, true), format: "mined" };
    default:
      throw new Error(`No variant of SignDoc exists with 'format=${json["format"]}'`);
  }
}

// src/openapi/models/SignerInfo.ts
function SignerInfoFromJSON(json) {
  return SignerInfoFromJSONTyped(json, false);
}
function SignerInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signerAddress": EnrichedCosmosBechAddressFromJSON(json["signer_address"]),
    "publicKey": json["public_key"],
    "account": json["account"],
    "sequence": json["sequence"]
  };
}

// src/openapi/models/CosmosTransaction.ts
function CosmosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "cosmosTransactionTypeDetails": CosmosTransactionTypeDetailsFromJSON(json["cosmos_transaction_type_details"]),
    "memo": !exists(json, "memo") ? void 0 : json["memo"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "from": EnrichedCosmosBechAddressFromJSON(json["from"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "type": json["type"],
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "state": CosmosTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(CosmosTransactionStateChangeFromJSON),
    "signersInfo": json["signers_info"].map(SignerInfoFromJSON),
    "expectedResult": !exists(json, "expected_result") ? void 0 : CosmosTransactionResultFromJSON(json["expected_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : CosmosTransactionResultFromJSON(json["mined_result"]),
    "signDoc": !exists(json, "sign_doc") ? void 0 : SignDocFromJSON(json["sign_doc"])
  };
}

// src/openapi/models/CosmosTransferToAddressRequest.ts
function CosmosTransferToAddressRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": CosmosBechAddressToJSON(value.address)
  };
}

// src/openapi/models/CosmosTransferToVaultIdRequest.ts
function CosmosTransferToVaultIdRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_id": value.vaultId
  };
}

// src/openapi/models/CosmosVault.ts
function CosmosVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "mainAddress": json["main_address"],
    "evmAddress": json["evm_address"],
    "chainsAddresses": json["chains_addresses"].map(CosmosBechAddressEnrichedChainFromJSON)
  };
}

// src/openapi/models/CreateAptosMessageRequest.ts
function CreateAptosMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": AptosPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/CreateAptosMessageWithWaitRequest.ts
function CreateAptosMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": AptosPersonalMessageRequestToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": AptosMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateAptosSerializedRawTransactionRequest.ts
function CreateAptosSerializedRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "gas_config": AptosGasConfigRequestToJSON(value.gasConfig),
    "chain": AptosChainUniqueIdToJSON(value.chain),
    "serialized_transaction_payload": value.serializedTransactionPayload,
    "skip_prediction": value.skipPrediction,
    "push_mode": PushModeToJSON(value.pushMode)
  };
}

// src/openapi/models/CreateAptosTransferRequestTo.ts
function CreateAptosTransferRequestToToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "hex":
      return AptosRecipientHexToJSON(value);
    case "vault_id":
      return AptosRecipientVaultIdToJSON(value);
    default:
      throw new Error(`No variant of CreateAptosTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateAptosTransferRequestExplicitAmount.ts
function CreateAptosTransferRequestExplicitAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateAptosTransferRequestMaxAmount.ts
function CreateAptosTransferRequestMaxAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/CreateAptosTransferRequestValue.ts
function CreateAptosTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateAptosTransferRequestMaxAmountToJSON(value);
    case "value":
      return CreateAptosTransferRequestExplicitAmountToJSON(value);
    default:
      throw new Error(`No variant of CreateAptosTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateAptosTransferRequest.ts
function CreateAptosTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "gas_config": AptosGasConfigRequestToJSON(value.gasConfig),
    "to": CreateAptosTransferRequestToToJSON(value.to),
    "value": CreateAptosTransferRequestValueToJSON(value.value),
    "asset_identifier": AptosAssetIdentifierRequestToJSON(value.assetIdentifier),
    "skip_prediction": value.skipPrediction,
    "push_mode": PushModeToJSON(value.pushMode)
  };
}

// src/openapi/models/CreateAptosTransactionRequestDetails.ts
function CreateAptosTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos_serialized_entry_point_payload":
      return CreateAptosSerializedRawTransactionRequestToJSON(value);
    case "aptos_transfer":
      return CreateAptosTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateAptosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateAptosTransactionRequest.ts
function CreateAptosTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateAptosTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/CreateAptosTransactionWithWaitRequest.ts
function CreateAptosTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateAptosTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": AptosTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/ImportVaultOptions.ts
function ImportVaultOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "derivation_path": value.derivationPath
  };
}

// src/openapi/models/CreateAptosVaultRequest.ts
function CreateAptosVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/SolanaNativeTransferDetails.ts
function SolanaNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "recipient": EnrichedSolanaAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SolanaRawTransactionDetails.ts
function SolanaRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipients": json["recipients"].map(EnrichedSolanaAddressFromJSON)
  };
}

// src/openapi/models/SolanaTokenTransferDetails.ts
function SolanaTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "recipient": EnrichedSolanaAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/PredictedSolanaTransactionSolanaTransactionTypeDetails.ts
function PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSON(json) {
  return PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return { ...SolanaNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "raw_transaction":
      return { ...SolanaRawTransactionDetailsFromJSONTyped(json, true), type: "raw_transaction" };
    case "token_transfer":
      return { ...SolanaTokenTransferDetailsFromJSONTyped(json, true), type: "token_transfer" };
    default:
      throw new Error(`No variant of PredictedSolanaTransactionSolanaTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SolanaBlockData.ts
function SolanaBlockDataFromJSON(json) {
  return SolanaBlockDataFromJSONTyped(json, false);
}
function SolanaBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "slot": json["slot"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/SolanaCompiledInstruction.ts
function SolanaCompiledInstructionFromJSON(json) {
  return SolanaCompiledInstructionFromJSONTyped(json, false);
}
function SolanaCompiledInstructionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "programIndex": json["program_index"],
    "data": json["data"],
    "accountIndexes": json["account_indexes"],
    "program": EnrichedSolanaAddressFromJSON(json["program"]),
    "base58Data": !exists(json, "base58_data") ? void 0 : json["base58_data"]
  };
}

// src/openapi/models/SolanaEnrichedMessageAddressTableLookup.ts
function SolanaEnrichedMessageAddressTableLookupFromJSON(json) {
  return SolanaEnrichedMessageAddressTableLookupFromJSONTyped(json, false);
}
function SolanaEnrichedMessageAddressTableLookupFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "accountKey": SolanaAddressFromJSON(json["account_key"]),
    "writableIndexes": json["writable_indexes"],
    "readonlyIndexes": json["readonly_indexes"],
    "state": AddressLookupTableStateFromJSON(json["state"])
  };
}

// src/openapi/models/SolanaTransactionAccount.ts
function SolanaTransactionAccountFromJSON(json) {
  return SolanaTransactionAccountFromJSONTyped(json, false);
}
function SolanaTransactionAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EnrichedSolanaAddressFromJSON(json["address"]),
    "writable": json["writable"],
    "signer": json["signer"]
  };
}

// src/openapi/models/InstructionError.ts
function InstructionErrorFromJSON(json) {
  return InstructionErrorFromJSONTyped(json, false);
}
function InstructionErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "errorType": json["error_type"],
    "instructionIndex": json["instruction_index"],
    "errorDescription": !exists(json, "error_description") ? void 0 : json["error_description"]
  };
}

// src/openapi/models/SolanaBalanceChangeEffectType.ts
function SolanaBalanceChangeEffectTypeFromJSON(json) {
  return SolanaBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function SolanaBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SplTokenContract.ts
function SplTokenContractFromJSON(json) {
  return SplTokenContractFromJSONTyped(json, false);
}
function SplTokenContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": SplTokenFromJSON(json["token"])
  };
}

// src/openapi/models/SolanaBalanceChangeEffect.ts
function SolanaBalanceChangeEffectFromJSON(json) {
  return SolanaBalanceChangeEffectFromJSONTyped(json, false);
}
function SolanaBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": SolanaBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedSolanaAddressFromJSON(json["address"]),
    "owner": !exists(json, "owner") ? void 0 : EnrichedSolanaAddressFromJSON(json["owner"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": !exists(json, "token_contract") ? void 0 : SplTokenContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/SolanaTransferEffectType.ts
function SolanaTransferEffectTypeFromJSON(json) {
  return SolanaTransferEffectTypeFromJSONTyped(json, false);
}
function SolanaTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaTransferEffect.ts
function SolanaTransferEffectFromJSON(json) {
  return SolanaTransferEffectFromJSONTyped(json, false);
}
function SolanaTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": SolanaTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedSolanaAddressFromJSON(json["from"]),
    "to": EnrichedSolanaAddressFromJSON(json["to"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": !exists(json, "token_contract") ? void 0 : SplTokenContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/SolanaEffects.ts
function SolanaEffectsFromJSON(json) {
  return SolanaEffectsFromJSONTyped(json, false);
}
function SolanaEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(SolanaBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(SolanaTransferEffectFromJSON)
  };
}

// src/openapi/models/SolanaFee.ts
function SolanaFeeFromJSON(json) {
  return SolanaFeeFromJSONTyped(json, false);
}
function SolanaFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "fee": json["fee"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/SolanaReversionState.ts
function SolanaReversionStateFromJSON(json) {
  return SolanaReversionStateFromJSONTyped(json, false);
}
function SolanaReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaReversion.ts
function SolanaReversionFromJSON(json) {
  return SolanaReversionFromJSONTyped(json, false);
}
function SolanaReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": SolanaReversionStateFromJSON(json["state"]),
    "reason": !exists(json, "reason") ? void 0 : json["reason"]
  };
}

// src/openapi/models/SolanaTransactionResult.ts
function SolanaTransactionResultFromJSON(json) {
  return SolanaTransactionResultFromJSONTyped(json, false);
}
function SolanaTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reversion": SolanaReversionFromJSON(json["reversion"]),
    "transactionError": !exists(json, "transaction_error") ? void 0 : json["transaction_error"],
    "fee": json["fee"],
    "enrichedFee": SolanaFeeFromJSON(json["enriched_fee"]),
    "effects": SolanaEffectsFromJSON(json["effects"]),
    "instructionError": !exists(json, "instruction_error") ? void 0 : InstructionErrorFromJSON(json["instruction_error"])
  };
}

// src/openapi/models/SolanaTransactionState.ts
function SolanaTransactionStateFromJSON(json) {
  return SolanaTransactionStateFromJSONTyped(json, false);
}
function SolanaTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/SolanaTransactionStateChange.ts
function SolanaTransactionStateChangeFromJSON(json) {
  return SolanaTransactionStateChangeFromJSONTyped(json, false);
}
function SolanaTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : SolanaTransactionStateFromJSON(json["previous_state"]),
    "newState": SolanaTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/SolanaTransaction.ts
function SolanaTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "solanaTransactionTypeDetails": PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSON(json["solana_transaction_type_details"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "state": SolanaTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(SolanaTransactionStateChangeFromJSON),
    "version": SolanaMessageVersionFromJSON(json["version"]),
    "instructions": json["instructions"].map(SolanaCompiledInstructionFromJSON),
    "accounts": json["accounts"].map(SolanaTransactionAccountFromJSON),
    "addressTableLookups": json["address_table_lookups"].map(SolanaEnrichedMessageAddressTableLookupFromJSON),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "rawTransaction": !exists(json, "raw_transaction") ? void 0 : json["raw_transaction"],
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "recentBlockhash": !exists(json, "recent_blockhash") ? void 0 : json["recent_blockhash"],
    "block": !exists(json, "block") ? void 0 : SolanaBlockDataFromJSON(json["block"]),
    "expectedResult": !exists(json, "expected_result") ? void 0 : SolanaTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : SolanaTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/IntegerHashPayload.ts
function IntegerHashPayloadToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "format": value.format,
    "hash_integer": value.hashInteger
  };
}

// src/openapi/models/CreateBlackBoxSignatureRequestDetails.ts
function CreateBlackBoxSignatureRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["format"]) {
    case "hash_binary":
      return BinaryHashPayloadToJSON(value);
    case "hash_integer":
      return IntegerHashPayloadToJSON(value);
    default:
      throw new Error(`No variant of CreateBlackBoxSignatureRequestDetails exists with 'format=${value["format"]}'`);
  }
}

// src/openapi/models/CreateBlackBoxSignatureRequest.ts
function CreateBlackBoxSignatureRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateBlackBoxSignatureRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/CreateBlackBoxSignatureWithWaitRequest.ts
function CreateBlackBoxSignatureWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateBlackBoxSignatureRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": BlackBoxSignatureStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateBlackBoxVaultRequest.ts
function CreateBlackBoxVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type,
    "key_type": value.keyType
  };
}

// src/openapi/models/CreateCosmosMessageRequest.ts
function CreateCosmosMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CosmosArbitraryMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/CreateCosmosMessageWithWaitRequest.ts
function CreateCosmosMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CosmosArbitraryMessageRequestToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": CosmosMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/DirectRequestData.ts
function DirectRequestDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "format": value.format,
    "body": value.body,
    "auth_info": value.authInfo,
    "account_number": value.accountNumber
  };
}

// src/openapi/models/TypedCosmosRawTransactionRequestRequestData.ts
function TypedCosmosRawTransactionRequestRequestDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["format"]) {
    case "amino":
      return AminoRequestDataToJSON(value);
    case "direct":
      return DirectRequestDataToJSON(value);
    default:
      throw new Error(`No variant of TypedCosmosRawTransactionRequestRequestData exists with 'format=${value["format"]}'`);
  }
}

// src/openapi/models/TypedCosmosRawTransactionRequest.ts
function TypedCosmosRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "push_mode": PushModeToJSON(value.pushMode),
    "chain": CosmosChainUniqueIdToJSON(value.chain),
    "request_data": TypedCosmosRawTransactionRequestRequestDataToJSON(value.requestData)
  };
}

// src/openapi/models/TypedCosmosTransferRequestTo.ts
function TypedCosmosTransferRequestToToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "address":
      return CosmosTransferToAddressRequestToJSON(value);
    case "vault_id":
      return CosmosTransferToVaultIdRequestToJSON(value);
    default:
      throw new Error(`No variant of TypedCosmosTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateCosmosTransferRequestExplicitValue.ts
function CreateCosmosTransferRequestExplicitValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateCosmosTransferRequestMaxValue.ts
function CreateCosmosTransferRequestMaxValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/TypedCosmosTransferRequestValue.ts
function TypedCosmosTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateCosmosTransferRequestMaxValueToJSON(value);
    case "value":
      return CreateCosmosTransferRequestExplicitValueToJSON(value);
    default:
      throw new Error(`No variant of TypedCosmosTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TypedCosmosTransferRequest.ts
function TypedCosmosTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "push_mode": PushModeToJSON(value.pushMode),
    "to": TypedCosmosTransferRequestToToJSON(value.to),
    "asset_identifier": CosmosAssetIdentifierRequestToJSON(value.assetIdentifier),
    "value": TypedCosmosTransferRequestValueToJSON(value.value),
    "memo": value.memo
  };
}

// src/openapi/models/CreateCosmosTransactionRequestDetails.ts
function CreateCosmosTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "cosmos_raw_transaction":
      return TypedCosmosRawTransactionRequestToJSON(value);
    case "cosmos_transfer":
      return TypedCosmosTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateCosmosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateCosmosTransactionRequest.ts
function CreateCosmosTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateCosmosTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/CreateCosmosTransactionWithWaitRequest.ts
function CreateCosmosTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateCosmosTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": CosmosTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateCosmosVaultRequest.ts
function CreateCosmosVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/KeyType.ts
function KeyTypeFromJSON(json) {
  return KeyTypeFromJSONTyped(json, false);
}
function KeyTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmChainRequest.ts
function EvmChainRequestToJSON(value) {
  return value;
}

// src/openapi/models/CreateEvmPersonalMessageRequest.ts
var CreateEvmPersonalMessageRequestTypeEnum = {
  personalMessageType: "personal_message_type"
};
function CreateEvmPersonalMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": EvmChainRequestToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/CreateEvmTypedMessageRequest.ts
var CreateEvmTypedMessageRequestTypeEnum = {
  typedMessageType: "typed_message_type"
};
function CreateEvmTypedMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": EvmChainRequestToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/CreateEvmMessageRequestDetails.ts
function CreateEvmMessageRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "personal_message_type":
      return CreateEvmPersonalMessageRequestToJSON(value);
    case "typed_message_type":
      return CreateEvmTypedMessageRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateEvmMessageRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmMessageRequest.ts
var CreateEvmMessageRequestTypeEnum = {
  evmMessage: "evm_message"
};
function CreateEvmMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateEvmMessageRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/EvmMessageState.ts
function EvmMessageStateFromJSON(json) {
  return EvmMessageStateFromJSONTyped(json, false);
}
function EvmMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function EvmMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateEvmMessageWithWaitRequest.ts
function CreateEvmMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateEvmMessageRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": EvmMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/DynamicGasRequest.ts
var DynamicGasRequestTypeEnum = {
  dynamic: "dynamic"
};
function DynamicGasRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "max_priority_fee_per_gas": value.maxPriorityFeePerGas,
    "max_fee_per_gas": value.maxFeePerGas
  };
}

// src/openapi/models/LegacyGasRequest.ts
function LegacyGasRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "price": value.price
  };
}

// src/openapi/models/CustomGasRequestDetails.ts
function CustomGasRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "dynamic":
      return DynamicGasRequestToJSON(value);
    case "legacy":
      return LegacyGasRequestToJSON(value);
    default:
      throw new Error(`No variant of CustomGasRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CustomGasRequest.ts
var CustomGasRequestTypeEnum = {
  custom: "custom"
};
function CustomGasRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "gas_limit": value.gasLimit,
    "type": value.type,
    "details": CustomGasRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/GasPriorityLevelRequest.ts
var GasPriorityLevelRequest = {
  low: "low",
  medium: "medium",
  high: "high"
};
function GasPriorityLevelRequestToJSON(value) {
  return value;
}

// src/openapi/models/GasPriorityRequest.ts
var GasPriorityRequestTypeEnum = {
  priority: "priority"
};
function GasPriorityRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "gas_limit": value.gasLimit,
    "type": value.type,
    "priority_level": GasPriorityLevelRequestToJSON(value.priorityLevel)
  };
}

// src/openapi/models/CreateEvmRawTransactionRequestGas.ts
function CreateEvmRawTransactionRequestGasToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "custom":
      return CustomGasRequestToJSON(value);
    case "priority":
      return GasPriorityRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateEvmRawTransactionRequestGas exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/EvmDataRequestBase64.ts
function EvmDataRequestBase64ToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "raw_data": value.rawData
  };
}

// src/openapi/models/EvmDataRequestFullDetails.ts
function EvmDataRequestFullDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "method_name": value.methodName,
    "method_arguments": value.methodArguments
  };
}

// src/openapi/models/EvmDataRequestHex.ts
var EvmDataRequestHexTypeEnum = {
  hex: "hex"
};
function EvmDataRequestHexToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "hex_data": value.hexData
  };
}

// src/openapi/models/EvmDataRequest.ts
function EvmDataRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "base64":
      return EvmDataRequestBase64ToJSON(value);
    case "full_details":
      return EvmDataRequestFullDetailsToJSON(value);
    case "hex":
      return EvmDataRequestHexToJSON(value);
    default:
      throw new Error(`No variant of EvmDataRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmRawTransactionRequest.ts
var CreateEvmRawTransactionRequestTypeEnum = {
  evmRawTransaction: "evm_raw_transaction"
};
function CreateEvmRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "use_secure_node": value.useSecureNode,
    "gas": CreateEvmRawTransactionRequestGasToJSON(value.gas),
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_prediction": value.skipPrediction,
    "push_mode": PushModeToJSON(value.pushMode),
    "funder": value.funder,
    "chain": EvmChainRequestToJSON(value.chain),
    "to": value.to,
    "value": value.value,
    "data": EvmDataRequestToJSON(value.data)
  };
}

// src/openapi/models/CreateEvmRevokeAllowanceRequest.ts
function CreateEvmRevokeAllowanceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "use_secure_node": value.useSecureNode,
    "gas": CreateEvmRawTransactionRequestGasToJSON(value.gas),
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_prediction": value.skipPrediction,
    "push_mode": PushModeToJSON(value.pushMode),
    "funder": value.funder,
    "chain": EvmChainRequestToJSON(value.chain),
    "token": value.token,
    "spender": value.spender
  };
}

// src/openapi/models/CreateEvmTransferRequestTo.ts
function CreateEvmTransferRequestToToJSON(value) {
  return value;
}

// src/openapi/models/CreateEvmTransferRequestExplicitValue.ts
function CreateEvmTransferRequestExplicitValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateEvmTransferRequestMaxValue.ts
function CreateEvmTransferRequestMaxValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/CreateEvmTransferRequestValue.ts
function CreateEvmTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateEvmTransferRequestMaxValueToJSON(value);
    case "value":
      return CreateEvmTransferRequestExplicitValueToJSON(value);
    default:
      throw new Error(`No variant of CreateEvmTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmTransferRequest.ts
function CreateEvmTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "use_secure_node": value.useSecureNode,
    "gas": CreateEvmRawTransactionRequestGasToJSON(value.gas),
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_prediction": value.skipPrediction,
    "push_mode": PushModeToJSON(value.pushMode),
    "funder": value.funder,
    "to": CreateEvmTransferRequestToToJSON(value.to),
    "chain": EvmChainRequestToJSON(value.chain),
    "token": value.token,
    "asset_identifier": EvmAssetIdentifierRequestToJSON(value.assetIdentifier),
    "value": CreateEvmTransferRequestValueToJSON(value.value)
  };
}

// src/openapi/models/CreateEvmTransactionRequestDetails.ts
function CreateEvmTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "evm_raw_transaction":
      return CreateEvmRawTransactionRequestToJSON(value);
    case "evm_revoke_allowance":
      return CreateEvmRevokeAllowanceRequestToJSON(value);
    case "evm_transfer":
      return CreateEvmTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateEvmTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmTransactionRequest.ts
var CreateEvmTransactionRequestTypeEnum = {
  evmTransaction: "evm_transaction"
};
function CreateEvmTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateEvmTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/EvmTransactionState.ts
var EvmTransactionState = {
  waitingForApproval: "waiting_for_approval",
  waitingForSigningTrigger: "waiting_for_signing_trigger",
  approved: "approved",
  signed: "signed",
  pushedToBlockchain: "pushed_to_blockchain",
  queued: "queued",
  mined: "mined",
  completed: "completed",
  aborting: "aborting",
  dropped: "dropped",
  aborted: "aborted",
  errorSigning: "error_signing",
  errorPushingToBlockchain: "error_pushing_to_blockchain",
  minedReverted: "mined_reverted",
  completedReverted: "completed_reverted",
  stuck: "stuck",
  accelerating: "accelerating",
  canceling: "canceling",
  accelerated: "accelerated",
  cancelled: "cancelled"
};
function EvmTransactionStateFromJSON(json) {
  return EvmTransactionStateFromJSONTyped(json, false);
}
function EvmTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function EvmTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateEvmTransactionWithWaitRequest.ts
function CreateEvmTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateEvmTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": EvmTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateEvmVaultRequest.ts
function CreateEvmVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/ExchangeType.ts
function ExchangeTypeFromJSON(json) {
  return ExchangeTypeFromJSONTyped(json, false);
}
function ExchangeTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmVault.ts
function EvmVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/ExchangeVault.ts
function ExchangeVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "type": json["type"],
    "exchangeType": ExchangeTypeFromJSON(json["exchange_type"]),
    "apiKey": json["api_key"]
  };
}

// src/openapi/models/SolanaVault.ts
function SolanaVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/SuiVault.ts
function SuiVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/TonVault.ts
function TonVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "rawAccount": json["raw_account"],
    "base64UrlBounceableAccount": json["base64_url_bounceable_account"],
    "base64UrlNonBounceableAccount": json["base64_url_non_bounceable_account"],
    "stateInit": json["state_init"]
  };
}

// src/openapi/models/UtxoVaultAddress.ts
function UtxoVaultAddressFromJSON(json) {
  return UtxoVaultAddressFromJSONTyped(json, false);
}
function UtxoVaultAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "vault": VaultRefFromJSON(json["vault"]),
    "name": json["name"],
    "balance": !exists(json, "balance") ? void 0 : json["balance"],
    "balances": BalancesFromJSON(json["balances"]),
    "publicKeyCompressed": json["public_key_compressed"],
    "type": json["type"],
    "address": UtxoAddressFromJSON(json["address"])
  };
}

// src/openapi/models/UtxoVault.ts
function UtxoVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": !exists(json, "metadata") ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": !exists(json, "pending_vault_group_action") ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": !exists(json, "key_holder") ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "defaultAddress": UtxoVaultAddressFromJSON(json["default_address"]),
    "defaultNextAddressName": json["default_next_address_name"],
    "taprootKeyPublicCompressed": !exists(json, "taproot_key_public_compressed") ? void 0 : json["taproot_key_public_compressed"],
    "taprootKeyDerivationInfo": !exists(json, "taproot_key_derivation_info") ? void 0 : VaultDerivationInfoFromJSON(json["taproot_key_derivation_info"])
  };
}

// src/openapi/models/SolanaPersonalMessageRequest.ts
function SolanaPersonalMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": SolanaChainUniqueIdToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/CreateSolanaMessageRequest.ts
function CreateSolanaMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": SolanaPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/SolanaMessageState.ts
function SolanaMessageStateFromJSON(json) {
  return SolanaMessageStateFromJSONTyped(json, false);
}
function SolanaMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateSolanaMessageWithWaitRequest.ts
function CreateSolanaMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": SolanaPersonalMessageRequestToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": SolanaMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateSolanaRawTransactionRequest.ts
function CreateSolanaRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": SolanaMessageVersionToJSON(value.version),
    "instructions": value.instructions.map(SolanaCompiledInstructionRequestToJSON),
    "accounts": value.accounts.map(SolanaTransactionAccountRequestToJSON),
    "address_table_lookups": value.addressTableLookups.map(SolanaMessageAddressTableLookupRequestToJSON),
    "signatures": value.signatures === void 0 ? void 0 : value.signatures.map(SolanaTransactionSignaturesRequestToJSON),
    "recent_blockhash": value.recentBlockhash,
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "chain": SolanaChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/SolanaSecretKeyRequest.ts
function SolanaSecretKeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}

// src/openapi/models/CreateSolanaSerializedTransactionMessageRequest.ts
function CreateSolanaSerializedTransactionMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "chain": SolanaChainUniqueIdToJSON(value.chain),
    "data": value.data,
    "signatures": value.signatures === void 0 ? void 0 : value.signatures.map(SolanaTransactionSignaturesRequestToJSON),
    "ephemeral_keys": value.ephemeralKeys === void 0 ? void 0 : value.ephemeralKeys.map(SolanaSecretKeyRequestToJSON)
  };
}

// src/openapi/models/CreateSolanaTransferRequestTo.ts
function CreateSolanaTransferRequestToToJSON(value) {
  return value;
}

// src/openapi/models/CreateSolanaTransferRequestExplicitAmount.ts
function CreateSolanaTransferRequestExplicitAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateSolanaTransferRequestMaxAmount.ts
function CreateSolanaTransferRequestMaxAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/CreateSolanaTransferRequestValue.ts
function CreateSolanaTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateSolanaTransferRequestMaxAmountToJSON(value);
    case "value":
      return CreateSolanaTransferRequestExplicitAmountToJSON(value);
    default:
      throw new Error(`No variant of CreateSolanaTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSolanaTransferRequest.ts
function CreateSolanaTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "to": CreateSolanaTransferRequestToToJSON(value.to),
    "value": CreateSolanaTransferRequestValueToJSON(value.value),
    "asset_identifier": SolanaAssetIdentifierRequestToJSON(value.assetIdentifier)
  };
}

// src/openapi/models/CreateSolanaTransactionRequestDetails.ts
function CreateSolanaTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "solana_raw_transaction":
      return CreateSolanaRawTransactionRequestToJSON(value);
    case "solana_serialized_transaction_message":
      return CreateSolanaSerializedTransactionMessageRequestToJSON(value);
    case "solana_transfer":
      return CreateSolanaTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateSolanaTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSolanaTransactionRequest.ts
function CreateSolanaTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateSolanaTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/CreateSolanaTransactionWithWaitRequest.ts
function CreateSolanaTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateSolanaTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": SolanaTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateSolanaVaultRequest.ts
function CreateSolanaVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/SuiPersonalMessageRequest.ts
function SuiPersonalMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": SuiChainUniqueIdToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/CreateSuiMessageRequest.ts
function CreateSuiMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": SuiPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/SuiMessageState.ts
function SuiMessageStateFromJSON(json) {
  return SuiMessageStateFromJSONTyped(json, false);
}
function SuiMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SuiMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateSuiMessageWithWaitRequest.ts
function CreateSuiMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": SuiPersonalMessageRequestToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": SuiMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/SuiCommandGasCoinArgument.ts
function SuiCommandGasCoinArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}
function SuiCommandGasCoinArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/SuiCommandInputArgument.ts
function SuiCommandInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"]
  };
}
function SuiCommandInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "index": value.index
  };
}

// src/openapi/models/SuiCommandNestedResultArgument.ts
function SuiCommandNestedResultArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"],
    "resultIndex": json["result_index"]
  };
}
function SuiCommandNestedResultArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "index": value.index,
    "result_index": value.resultIndex
  };
}

// src/openapi/models/SuiCommandResultArgument.ts
function SuiCommandResultArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"]
  };
}
function SuiCommandResultArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "index": value.index
  };
}

// src/openapi/models/SuiCommandArgument.ts
function SuiCommandArgumentFromJSON(json) {
  return SuiCommandArgumentFromJSONTyped(json, false);
}
function SuiCommandArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "gas_coin":
      return { ...SuiCommandGasCoinArgumentFromJSONTyped(json, true), type: "gas_coin" };
    case "input":
      return { ...SuiCommandInputArgumentFromJSONTyped(json, true), type: "input" };
    case "nested_result":
      return { ...SuiCommandNestedResultArgumentFromJSONTyped(json, true), type: "nested_result" };
    case "result":
      return { ...SuiCommandResultArgumentFromJSONTyped(json, true), type: "result" };
    default:
      throw new Error(`No variant of SuiCommandArgument exists with 'type=${json["type"]}'`);
  }
}
function SuiCommandArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "gas_coin":
      return SuiCommandGasCoinArgumentToJSON(value);
    case "input":
      return SuiCommandInputArgumentToJSON(value);
    case "nested_result":
      return SuiCommandNestedResultArgumentToJSON(value);
    case "result":
      return SuiCommandResultArgumentToJSON(value);
    default:
      throw new Error(`No variant of SuiCommandArgument exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiMakeMoveVecCommand.ts
function SuiMakeMoveVecCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "typeTag": !exists(json, "type_tag") ? void 0 : json["type_tag"],
    "objects": json["objects"].map(SuiCommandArgumentFromJSON)
  };
}
function SuiMakeMoveVecCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "type_tag": value.typeTag,
    "objects": value.objects.map(SuiCommandArgumentToJSON)
  };
}

// src/openapi/models/SuiMergeCoinsCommand.ts
function SuiMergeCoinsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sourceCoinObjects": json["source_coin_objects"].map(SuiCommandArgumentFromJSON),
    "destinationCoinObject": SuiCommandArgumentFromJSON(json["destination_coin_object"])
  };
}
function SuiMergeCoinsCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "source_coin_objects": value.sourceCoinObjects.map(SuiCommandArgumentToJSON),
    "destination_coin_object": SuiCommandArgumentToJSON(value.destinationCoinObject)
  };
}

// src/openapi/models/SuiMoveCallCommand.ts
function SuiMoveCallCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "arguments": json["arguments"].map(SuiCommandArgumentFromJSON),
    "target": json["target"],
    "typeArguments": json["type_arguments"]
  };
}
function SuiMoveCallCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "arguments": value.arguments.map(SuiCommandArgumentToJSON),
    "target": value.target,
    "type_arguments": value.typeArguments
  };
}

// src/openapi/models/SuiSplitCoinsCommand.ts
function SuiSplitCoinsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinObject": SuiCommandArgumentFromJSON(json["coin_object"]),
    "amounts": json["amounts"].map(SuiCommandArgumentFromJSON)
  };
}
function SuiSplitCoinsCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "coin_object": SuiCommandArgumentToJSON(value.coinObject),
    "amounts": value.amounts.map(SuiCommandArgumentToJSON)
  };
}

// src/openapi/models/SuiTransferObjectsCommand.ts
function SuiTransferObjectsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "objects": json["objects"].map(SuiCommandArgumentFromJSON),
    "address": SuiCommandArgumentFromJSON(json["address"])
  };
}
function SuiTransferObjectsCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "objects": value.objects.map(SuiCommandArgumentToJSON),
    "address": SuiCommandArgumentToJSON(value.address)
  };
}

// src/openapi/models/SuiCommand.ts
function SuiCommandFromJSON(json) {
  return SuiCommandFromJSONTyped(json, false);
}
function SuiCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "make_move_vec":
      return { ...SuiMakeMoveVecCommandFromJSONTyped(json, true), type: "make_move_vec" };
    case "merge_coins":
      return { ...SuiMergeCoinsCommandFromJSONTyped(json, true), type: "merge_coins" };
    case "move_call":
      return { ...SuiMoveCallCommandFromJSONTyped(json, true), type: "move_call" };
    case "split_coins":
      return { ...SuiSplitCoinsCommandFromJSONTyped(json, true), type: "split_coins" };
    case "transfer_objects":
      return { ...SuiTransferObjectsCommandFromJSONTyped(json, true), type: "transfer_objects" };
    default:
      throw new Error(`No variant of SuiCommand exists with 'type=${json["type"]}'`);
  }
}
function SuiCommandToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "make_move_vec":
      return SuiMakeMoveVecCommandToJSON(value);
    case "merge_coins":
      return SuiMergeCoinsCommandToJSON(value);
    case "move_call":
      return SuiMoveCallCommandToJSON(value);
    case "split_coins":
      return SuiSplitCoinsCommandToJSON(value);
    case "transfer_objects":
      return SuiTransferObjectsCommandToJSON(value);
    default:
      throw new Error(`No variant of SuiCommand exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiObjectRef.ts
function SuiObjectRefFromJSON(json) {
  return SuiObjectRefFromJSONTyped(json, false);
}
function SuiObjectRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"]
  };
}
function SuiObjectRefToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "digest": value.digest,
    "object_id": value.objectId,
    "version": value.version
  };
}

// src/openapi/models/SuiGasConfig.ts
function SuiGasConfigFromJSON(json) {
  return SuiGasConfigFromJSONTyped(json, false);
}
function SuiGasConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "budget": !exists(json, "budget") ? void 0 : json["budget"],
    "price": !exists(json, "price") ? void 0 : json["price"],
    "payment": json["payment"].map(SuiObjectRefFromJSON)
  };
}
function SuiGasConfigToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "budget": value.budget,
    "price": value.price,
    "payment": value.payment.map(SuiObjectRefToJSON)
  };
}

// src/openapi/models/SuiImmOrOwnedObjectRefInputArgument.ts
function SuiImmOrOwnedObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"],
    "type": json["type"]
  };
}
function SuiImmOrOwnedObjectRefInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "digest": value.digest,
    "object_id": value.objectId,
    "version": value.version,
    "type": value.type
  };
}

// src/openapi/models/SuiPartialObjectRefInputArgument.ts
function SuiPartialObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "objectId": json["object_id"]
  };
}
function SuiPartialObjectRefInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "object_id": value.objectId
  };
}

// src/openapi/models/SuiReceivingObjectRefInputArgument.ts
function SuiReceivingObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"],
    "type": json["type"]
  };
}
function SuiReceivingObjectRefInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "digest": value.digest,
    "object_id": value.objectId,
    "version": value.version,
    "type": value.type
  };
}

// src/openapi/models/SuiSharedObjectRefInputArgument.ts
function SuiSharedObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "objectId": json["object_id"],
    "initialSharedVersion": json["initial_shared_version"],
    "mutable": json["mutable"]
  };
}
function SuiSharedObjectRefInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "object_id": value.objectId,
    "initial_shared_version": value.initialSharedVersion,
    "mutable": value.mutable
  };
}

// src/openapi/models/SuiObjectInputArgumentDetails.ts
function SuiObjectInputArgumentDetailsFromJSON(json) {
  return SuiObjectInputArgumentDetailsFromJSONTyped(json, false);
}
function SuiObjectInputArgumentDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "imm_or_owned":
      return { ...SuiImmOrOwnedObjectRefInputArgumentFromJSONTyped(json, true), type: "imm_or_owned" };
    case "partial":
      return { ...SuiPartialObjectRefInputArgumentFromJSONTyped(json, true), type: "partial" };
    case "receiving":
      return { ...SuiReceivingObjectRefInputArgumentFromJSONTyped(json, true), type: "receiving" };
    case "shared":
      return { ...SuiSharedObjectRefInputArgumentFromJSONTyped(json, true), type: "shared" };
    default:
      throw new Error(`No variant of SuiObjectInputArgumentDetails exists with 'type=${json["type"]}'`);
  }
}
function SuiObjectInputArgumentDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "imm_or_owned":
      return SuiImmOrOwnedObjectRefInputArgumentToJSON(value);
    case "partial":
      return SuiPartialObjectRefInputArgumentToJSON(value);
    case "receiving":
      return SuiReceivingObjectRefInputArgumentToJSON(value);
    case "shared":
      return SuiSharedObjectRefInputArgumentToJSON(value);
    default:
      throw new Error(`No variant of SuiObjectInputArgumentDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiObjectInputArgument.ts
function SuiObjectInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SuiObjectInputArgumentDetailsFromJSON(json["details"])
  };
}
function SuiObjectInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": SuiObjectInputArgumentDetailsToJSON(value.details)
  };
}

// src/openapi/models/SuiPureInputArgument.ts
function SuiPureInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": BaseSuiPureInputFromJSON(json["details"])
  };
}
function SuiPureInputArgumentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "details": BaseSuiPureInputToJSON(value.details)
  };
}

// src/openapi/models/SuiInput.ts
function SuiInputFromJSON(json) {
  return SuiInputFromJSONTyped(json, false);
}
function SuiInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "object":
      return { ...SuiObjectInputArgumentFromJSONTyped(json, true), type: "object" };
    case "pure":
      return { ...SuiPureInputArgumentFromJSONTyped(json, true), type: "pure" };
    default:
      throw new Error(`No variant of SuiInput exists with 'type=${json["type"]}'`);
  }
}
function SuiInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "object":
      return SuiObjectInputArgumentToJSON(value);
    case "pure":
      return SuiPureInputArgumentToJSON(value);
    default:
      throw new Error(`No variant of SuiInput exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiProgrammableTransactionBlockRequest.ts
function CreateSuiProgrammableTransactionBlockRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "chain": SuiChainUniqueIdToJSON(value.chain),
    "gas_config": SuiGasConfigToJSON(value.gasConfig),
    "inputs": value.inputs.map(SuiInputToJSON),
    "commands": value.commands.map(SuiCommandToJSON)
  };
}

// src/openapi/models/CreateSuiSerializedTransactionDataRequest.ts
function CreateSuiSerializedTransactionDataRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "chain": SuiChainUniqueIdToJSON(value.chain),
    "data": value.data
  };
}

// src/openapi/models/SuiRecipientHex.ts
function SuiRecipientHexToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": value.address
  };
}

// src/openapi/models/SuiRecipientVaultId.ts
function SuiRecipientVaultIdToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_id": value.vaultId
  };
}

// src/openapi/models/CreateSuiTransferRequestTo.ts
function CreateSuiTransferRequestToToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "hex":
      return SuiRecipientHexToJSON(value);
    case "vault_id":
      return SuiRecipientVaultIdToJSON(value);
    default:
      throw new Error(`No variant of CreateSuiTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiTransferRequestExplicitAmount.ts
function CreateSuiTransferRequestExplicitAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateSuiTransferRequestMaxAmount.ts
function CreateSuiTransferRequestMaxAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/CreateSuiTransferRequestValue.ts
function CreateSuiTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateSuiTransferRequestMaxAmountToJSON(value);
    case "value":
      return CreateSuiTransferRequestExplicitAmountToJSON(value);
    default:
      throw new Error(`No variant of CreateSuiTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiTransferRequest.ts
function CreateSuiTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "skip_prediction": value.skipPrediction,
    "to": CreateSuiTransferRequestToToJSON(value.to),
    "gas_config": SuiGasConfigToJSON(value.gasConfig),
    "value": CreateSuiTransferRequestValueToJSON(value.value),
    "asset_identifier": SuiAssetIdentifierRequestToJSON(value.assetIdentifier)
  };
}

// src/openapi/models/CreateSuiTransactionRequestDetails.ts
function CreateSuiTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "sui_binary_canonical_serialization":
      return CreateSuiSerializedTransactionDataRequestToJSON(value);
    case "sui_programmable_transaction_block":
      return CreateSuiProgrammableTransactionBlockRequestToJSON(value);
    case "sui_transfer":
      return CreateSuiTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateSuiTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiTransactionRequest.ts
function CreateSuiTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateSuiTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/SuiTransactionState.ts
function SuiTransactionStateFromJSON(json) {
  return SuiTransactionStateFromJSONTyped(json, false);
}
function SuiTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SuiTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateSuiTransactionWithWaitRequest.ts
function CreateSuiTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateSuiTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": SuiTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateSuiVaultRequest.ts
function CreateSuiVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/TonProofMessageRequest.ts
function TonProofMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "domain": value.domain,
    "chain": TonChainUniqueIdToJSON(value.chain),
    "message_to_sign": value.messageToSign
  };
}

// src/openapi/models/CreateTonMessageRequest.ts
function CreateTonMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": TonProofMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TonMessageState.ts
function TonMessageStateFromJSON(json) {
  return TonMessageStateFromJSONTyped(json, false);
}
function TonMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateTonMessageWithWaitRequest.ts
function CreateTonMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": TonProofMessageRequestToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": TonMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/TonNetwork.ts
function TonNetworkFromJSON(json) {
  return TonNetworkFromJSONTyped(json, false);
}
function TonNetworkFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonNetworkToJSON(value) {
  return value;
}

// src/openapi/models/TonAccountRepr.ts
function TonAccountReprFromJSON(json) {
  return TonAccountReprFromJSONTyped(json, false);
}
function TonAccountReprFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"]
  };
}
function TonAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "address": value.address
  };
}

// src/openapi/models/TonTransactionMessage.ts
function TonTransactionMessageFromJSON(json) {
  return TonTransactionMessageFromJSONTyped(json, false);
}
function TonTransactionMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": TonAccountReprFromJSON(json["address"]),
    "amount": json["amount"],
    "payload": !exists(json, "payload") ? void 0 : json["payload"],
    "stateInit": !exists(json, "state_init") ? void 0 : json["state_init"]
  };
}
function TonTransactionMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": TonAccountReprToJSON(value.address),
    "amount": value.amount,
    "payload": value.payload,
    "state_init": value.stateInit
  };
}

// src/openapi/models/TonTransactionPayload.ts
function TonTransactionPayloadFromJSON(json) {
  return TonTransactionPayloadFromJSONTyped(json, false);
}
function TonTransactionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "validUntil": !exists(json, "valid_until") ? void 0 : json["valid_until"],
    "network": !exists(json, "network") ? void 0 : TonNetworkFromJSON(json["network"]),
    "messages": json["messages"].map(TonTransactionMessageFromJSON)
  };
}
function TonTransactionPayloadToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "valid_until": value.validUntil,
    "network": TonNetworkToJSON(value.network),
    "messages": value.messages.map(TonTransactionMessageToJSON)
  };
}

// src/openapi/models/CreateTonSerializedRawTransactionRequest.ts
function CreateTonSerializedRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "chain": TonChainUniqueIdToJSON(value.chain),
    "transaction_payload": TonTransactionPayloadToJSON(value.transactionPayload),
    "skip_prediction": value.skipPrediction
  };
}

// src/openapi/models/TonRecipientHex.ts
function TonRecipientHexToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": value.address
  };
}

// src/openapi/models/TonRecipientVaultId.ts
function TonRecipientVaultIdToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_id": value.vaultId
  };
}

// src/openapi/models/CreateTonTransferRequestTo.ts
function CreateTonTransferRequestToToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "hex":
      return TonRecipientHexToJSON(value);
    case "vault_id":
      return TonRecipientVaultIdToJSON(value);
    default:
      throw new Error(`No variant of CreateTonTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTonTransferRequestExplicitAmount.ts
function CreateTonTransferRequestExplicitAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "value": value.value
  };
}

// src/openapi/models/CreateTonTransferRequestMaxAmount.ts
function CreateTonTransferRequestMaxAmountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type
  };
}

// src/openapi/models/CreateTonTransferRequestValue.ts
function CreateTonTransferRequestValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "max":
      return CreateTonTransferRequestMaxAmountToJSON(value);
    case "value":
      return CreateTonTransferRequestExplicitAmountToJSON(value);
    default:
      throw new Error(`No variant of CreateTonTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTonTransferRequest.ts
function CreateTonTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "to": CreateTonTransferRequestToToJSON(value.to),
    "value": CreateTonTransferRequestValueToJSON(value.value),
    "asset_identifier": TonAssetIdentifierRequestToJSON(value.assetIdentifier),
    "skip_prediction": value.skipPrediction
  };
}

// src/openapi/models/CreateTonTransactionRequestDetails.ts
function CreateTonTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "ton_contract_call_payload":
      return CreateTonSerializedRawTransactionRequestToJSON(value);
    case "ton_transfer":
      return CreateTonTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateTonTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTonTransactionRequest.ts
function CreateTonTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateTonTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TonTransactionState.ts
function TonTransactionStateFromJSON(json) {
  return TonTransactionStateFromJSONTyped(json, false);
}
function TonTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/CreateTonTransactionWithWaitRequest.ts
function CreateTonTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateTonTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": TonTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateTonVaultRequest.ts
function CreateTonVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type
  };
}

// src/openapi/models/UtxoMessageType.ts
function UtxoMessageTypeFromJSON(json) {
  return UtxoMessageTypeFromJSONTyped(json, false);
}
function UtxoMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoMessageTypeToJSON(value) {
  return value;
}

// src/openapi/models/UtxoMessageDetails.ts
function UtxoMessageDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": UtxoMessageTypeToJSON(value.type),
    "sender": UtxoAddressToJSON(value.sender),
    "raw_data": value.rawData
  };
}

// src/openapi/models/CreateUtxoMessageRequest.ts
function CreateUtxoMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": UtxoMessageDetailsToJSON(value.details)
  };
}

// src/openapi/models/PsbtSignerIdentityAddress.ts
function PsbtSignerIdentityAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": value.address
  };
}

// src/openapi/models/PsbtSignerIdentityPublicKey.ts
function PsbtSignerIdentityPublicKeyToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "public_key": value.publicKey
  };
}

// src/openapi/models/PsbtInputSignerIdentity.ts
function PsbtInputSignerIdentityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "address":
      return PsbtSignerIdentityAddressToJSON(value);
    case "public_key":
      return PsbtSignerIdentityPublicKeyToJSON(value);
    default:
      throw new Error(`No variant of PsbtInputSignerIdentity exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/PsbtInput.ts
function PsbtInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "index": value.index,
    "signer_identity": PsbtInputSignerIdentityToJSON(value.signerIdentity),
    "sighash_types": value.sighashTypes,
    "disable_tweak_signer": value.disableTweakSigner
  };
}

// src/openapi/models/TransactionDetailsUtxoPsbtRequest.ts
function TransactionDetailsUtxoPsbtRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "psbt_raw_data": value.psbtRawData,
    "auto_finalize": value.autoFinalize,
    "sender": UtxoAddressToJSON(value.sender),
    "inputs": value.inputs === void 0 ? void 0 : value.inputs.map(PsbtInputToJSON),
    "push_mode": PushModeToJSON(value.pushMode)
  };
}

// src/openapi/models/CustomFeeRequest.ts
function CustomFeeRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fee_per_byte": value.feePerByte
  };
}

// src/openapi/models/FeePriorityLevelRequest.ts
function FeePriorityLevelRequestToJSON(value) {
  return value;
}

// src/openapi/models/FeePriorityRequest.ts
function FeePriorityRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "priority_level": FeePriorityLevelRequestToJSON(value.priorityLevel)
  };
}

// src/openapi/models/TransactionDetailsUtxoTransferRequestFeePerByte.ts
function TransactionDetailsUtxoTransferRequestFeePerByteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "custom":
      return CustomFeeRequestToJSON(value);
    case "priority":
      return FeePriorityRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsUtxoTransferRequestFeePerByte exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/UtxoOutputToAddressRequest.ts
function UtxoOutputToAddressRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "address": value.address
  };
}

// src/openapi/models/UtxoOutputToVaultAddressIdRequest.ts
function UtxoOutputToVaultAddressIdRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_address_id": value.vaultAddressId
  };
}

// src/openapi/models/UtxoOutputToVaultIdRequest.ts
function UtxoOutputToVaultIdRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "vault_id": value.vaultId
  };
}

// src/openapi/models/UtxoOutputRequestTo.ts
function UtxoOutputRequestToToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "address":
      return UtxoOutputToAddressRequestToJSON(value);
    case "vault_address_id":
      return UtxoOutputToVaultAddressIdRequestToJSON(value);
    case "vault_id":
      return UtxoOutputToVaultIdRequestToJSON(value);
    default:
      throw new Error(`No variant of UtxoOutputRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/UtxoOutputRequest.ts
function UtxoOutputRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "to": UtxoOutputRequestToToJSON(value.to),
    "value": value.value
  };
}

// src/openapi/models/TransactionDetailsUtxoTransferRequest.ts
function TransactionDetailsUtxoTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "outputs": value.outputs.map(UtxoOutputRequestToJSON),
    "fee_per_byte": TransactionDetailsUtxoTransferRequestFeePerByteToJSON(value.feePerByte),
    "push_mode": PushModeToJSON(value.pushMode)
  };
}

// src/openapi/models/CreateUtxoTransactionRequestDetails.ts
function CreateUtxoTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "utxo_partially_signed_bitcoin_transaction":
      return TransactionDetailsUtxoPsbtRequestToJSON(value);
    case "utxo_transfer":
      return TransactionDetailsUtxoTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateUtxoTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateUtxoTransactionRequest.ts
function CreateUtxoTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateUtxoTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/CreateTransactionRequest.ts
function CreateTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos_message":
      return CreateAptosMessageRequestToJSON(value);
    case "aptos_transaction":
      return CreateAptosTransactionRequestToJSON(value);
    case "black_box_signature":
      return CreateBlackBoxSignatureRequestToJSON(value);
    case "cosmos_message":
      return CreateCosmosMessageRequestToJSON(value);
    case "cosmos_transaction":
      return CreateCosmosTransactionRequestToJSON(value);
    case "evm_message":
      return CreateEvmMessageRequestToJSON(value);
    case "evm_transaction":
      return CreateEvmTransactionRequestToJSON(value);
    case "solana_message":
      return CreateSolanaMessageRequestToJSON(value);
    case "solana_transaction":
      return CreateSolanaTransactionRequestToJSON(value);
    case "sui_message":
      return CreateSuiMessageRequestToJSON(value);
    case "sui_transaction":
      return CreateSuiTransactionRequestToJSON(value);
    case "ton_message":
      return CreateTonMessageRequestToJSON(value);
    case "ton_transaction":
      return CreateTonTransactionRequestToJSON(value);
    case "utxo_message":
      return CreateUtxoMessageRequestToJSON(value);
    case "utxo_transaction":
      return CreateUtxoTransactionRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateTransactionRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/PricedErc20.ts
function PricedErc20FromJSON(json) {
  return PricedErc20FromJSONTyped(json, false);
}
function PricedErc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "price": json["price"],
    "priceFloat": json["price_float"],
    "fiatCurrency": FiatCurrencyFromJSON(json["fiat_currency"]),
    "token": Erc20FromJSON(json["token"])
  };
}

// src/openapi/models/EvmPrices.ts
function EvmPricesFromJSON(json) {
  return EvmPricesFromJSONTyped(json, false);
}
function EvmPricesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nativeCurrencyPrice": !exists(json, "native_currency_price") ? void 0 : PriceFromJSON(json["native_currency_price"]),
    "tokenPrices": !exists(json, "token_prices") ? void 0 : json["token_prices"].map(PricedErc20FromJSON)
  };
}

// src/openapi/models/EvmMessageStateChange.ts
function EvmMessageStateChangeFromJSON(json) {
  return EvmMessageStateChangeFromJSONTyped(json, false);
}
function EvmMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "prices": EvmPricesFromJSON(json["prices"]),
    "previousState": !exists(json, "previous_state") ? void 0 : EvmMessageStateFromJSON(json["previous_state"]),
    "newState": EvmMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/EvmMessageType.ts
function EvmMessageTypeFromJSON(json) {
  return EvmMessageTypeFromJSONTyped(json, false);
}
function EvmMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmMessageDomainData.ts
function EvmMessageDomainDataFromJSON(json) {
  return EvmMessageDomainDataFromJSONTyped(json, false);
}
function EvmMessageDomainDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "version": !exists(json, "version") ? void 0 : json["version"],
    "chainId": !exists(json, "chain_id") ? void 0 : json["chain_id"],
    "verifyingContract": !exists(json, "verifying_contract") ? void 0 : EnrichedEvmAddressFromJSON(json["verifying_contract"]),
    "salt": !exists(json, "salt") ? void 0 : json["salt"]
  };
}

// src/openapi/models/Permit2TypedMessageEvmMessage.ts
function Permit2TypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "type": json["type"],
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "deadline": new Date(json["deadline"]),
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "value": json["value"],
    "expiration": new Date(json["expiration"]),
    "nonce": json["nonce"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/PermitTypedMessageEvmMessage.ts
function PermitTypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "value": json["value"],
    "deadline": new Date(json["deadline"]),
    "nonce": json["nonce"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UnknownTypedMessageEvmMessage.ts
function UnknownTypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EvmMessageTypedData.ts
function EvmMessageTypedDataFromJSON(json) {
  return EvmMessageTypedDataFromJSONTyped(json, false);
}
function EvmMessageTypedDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "permit":
      return { ...PermitTypedMessageEvmMessageFromJSONTyped(json, true), type: "permit" };
    case "permit2":
      return { ...Permit2TypedMessageEvmMessageFromJSONTyped(json, true), type: "permit2" };
    case "unknown":
      return { ...UnknownTypedMessageEvmMessageFromJSONTyped(json, true), type: "unknown" };
    default:
      throw new Error(`No variant of EvmMessageTypedData exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmMessage.ts
function EvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "evmMessageType": EvmMessageTypeFromJSON(json["evm_message_type"]),
    "state": EvmMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(EvmMessageStateChangeFromJSON),
    "rawData": json["raw_data"],
    "typedData": !exists(json, "typed_data") ? void 0 : EvmMessageTypedDataFromJSON(json["typed_data"]),
    "vault": VaultRefFromJSON(json["vault"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/EvmBlockData.ts
function EvmBlockDataFromJSON(json) {
  return EvmBlockDataFromJSONTyped(json, false);
}
function EvmBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/EvmNativeTransferDetails.ts
function EvmNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TokenTransferDetails.ts
function TokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "recipient": EnrichedEvmAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/EvmTransactionEvmTransactionTypeDetails.ts
function EvmTransactionEvmTransactionTypeDetailsFromJSON(json) {
  return EvmTransactionEvmTransactionTypeDetailsFromJSONTyped(json, false);
}
function EvmTransactionEvmTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "allowance":
      return { ...AllowanceDetailsFromJSONTyped(json, true), type: "allowance" };
    case "contract_call":
      return { ...ContractCallDetailsFromJSONTyped(json, true), type: "contract_call" };
    case "contract_deployment":
      return { ...ContractDeploymentDetailsFromJSONTyped(json, true), type: "contract_deployment" };
    case "cross_chain_bridge":
      return { ...BridgeDetailsFromJSONTyped(json, true), type: "cross_chain_bridge" };
    case "native_transfer":
      return { ...EvmNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "token_transfer":
      return { ...TokenTransferDetailsFromJSONTyped(json, true), type: "token_transfer" };
    default:
      throw new Error(`No variant of EvmTransactionEvmTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GasPriorityLevel.ts
function GasPriorityLevelFromJSON(json) {
  return GasPriorityLevelFromJSONTyped(json, false);
}
function GasPriorityLevelFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/DynamicGas.ts
function DynamicGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "maxPriorityFeePerGas": json["max_priority_fee_per_gas"],
    "maxFeePerGas": json["max_fee_per_gas"],
    "priority": GasPriorityLevelFromJSON(json["priority"]),
    "limit": json["limit"],
    "type": json["type"]
  };
}

// src/openapi/models/LegacyGas.ts
var LegacyGasTypeEnum = {
  legacy: "legacy"
};
function LegacyGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "price": json["price"],
    "priority": GasPriorityLevelFromJSON(json["priority"]),
    "limit": json["limit"],
    "type": json["type"]
  };
}

// src/openapi/models/EvmTransactionGasSubmitted.ts
function EvmTransactionGasSubmittedFromJSON(json) {
  return EvmTransactionGasSubmittedFromJSONTyped(json, false);
}
function EvmTransactionGasSubmittedFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "dynamic":
      return { ...DynamicGasFromJSONTyped(json, true), type: "dynamic" };
    case "legacy":
      return { ...LegacyGasFromJSONTyped(json, true), type: "legacy" };
    default:
      throw new Error(`No variant of EvmTransactionGasSubmitted exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmTransactionMethodArgument.ts
function EvmTransactionMethodArgumentFromJSON(json) {
  return EvmTransactionMethodArgumentFromJSONTyped(json, false);
}
function EvmTransactionMethodArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "type": json["type"],
    "value": json["value"],
    "enrichedAddress": !exists(json, "enriched_address") ? void 0 : EnrichedEvmAddressFromJSON(json["enriched_address"])
  };
}

// src/openapi/models/EvmTransactionParsedData.ts
function EvmTransactionParsedDataFromJSON(json) {
  return EvmTransactionParsedDataFromJSONTyped(json, false);
}
function EvmTransactionParsedDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "method": json["method"],
    "methodArguments": json["method_arguments"].map(EvmTransactionMethodArgumentFromJSON)
  };
}

// src/openapi/models/EvmBalanceChangeEffectTokenContract.ts
function EvmBalanceChangeEffectTokenContractFromJSON(json) {
  return EvmBalanceChangeEffectTokenContractFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectTokenContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc721FromJSON(json["token"])
  };
}

// src/openapi/models/EvmBalanceChangeEffectType.ts
function EvmBalanceChangeEffectTypeFromJSON(json) {
  return EvmBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmBalanceChangeEffect.ts
function EvmBalanceChangeEffectFromJSON(json) {
  return EvmBalanceChangeEffectFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": EvmBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedEvmAddressFromJSON(json["address"]),
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": !exists(json, "token_contract") ? void 0 : EvmBalanceChangeEffectTokenContractFromJSON(json["token_contract"]),
    "tokenId": !exists(json, "token_id") ? void 0 : json["token_id"],
    "owned": !exists(json, "owned") ? void 0 : json["owned"]
  };
}

// src/openapi/models/EvmContractDeploymentEffect.ts
function EvmContractDeploymentEffectFromJSON(json) {
  return EvmContractDeploymentEffectFromJSONTyped(json, false);
}
function EvmContractDeploymentEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EnrichedEvmAddressFromJSON(json["address"])
  };
}

// src/openapi/models/EvmTransferEffectTokenContract.ts
function EvmTransferEffectTokenContractFromJSON(json) {
  return EvmTransferEffectTokenContractFromJSONTyped(json, false);
}
function EvmTransferEffectTokenContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "dapp": !exists(json, "dapp") ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc1155FromJSON(json["token"])
  };
}

// src/openapi/models/EvmTransferEffectType.ts
function EvmTransferEffectTypeFromJSON(json) {
  return EvmTransferEffectTypeFromJSONTyped(json, false);
}
function EvmTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmTransferEffect.ts
function EvmTransferEffectFromJSON(json) {
  return EvmTransferEffectFromJSONTyped(json, false);
}
function EvmTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": EvmTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedEvmAddressFromJSON(json["from"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": !exists(json, "token_contract") ? void 0 : EvmTransferEffectTokenContractFromJSON(json["token_contract"]),
    "tokenId": !exists(json, "token_id") ? void 0 : json["token_id"]
  };
}

// src/openapi/models/EvmEffects.ts
function EvmEffectsFromJSON(json) {
  return EvmEffectsFromJSONTyped(json, false);
}
function EvmEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(EvmBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(EvmTransferEffectFromJSON),
    "allowances": json["allowances"].map(AllowanceEffectFromJSON),
    "bridge": json["bridge"].map(EvmBridgeEffectFromJSON),
    "contractDeployments": json["contract_deployments"].map(EvmContractDeploymentEffectFromJSON)
  };
}

// src/openapi/models/EvmReversionState.ts
function EvmReversionStateFromJSON(json) {
  return EvmReversionStateFromJSONTyped(json, false);
}
function EvmReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmReversion.ts
function EvmReversionFromJSON(json) {
  return EvmReversionFromJSONTyped(json, false);
}
function EvmReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": EvmReversionStateFromJSON(json["state"]),
    "reason": !exists(json, "reason") ? void 0 : json["reason"]
  };
}

// src/openapi/models/GasDebit.ts
function GasDebitFromJSON(json) {
  return GasDebitFromJSONTyped(json, false);
}
function GasDebitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "gasUsed": json["gas_used"],
    "gasPrice": json["gas_price"],
    "totalFee": json["total_fee"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/EvmTransactionResult.ts
function EvmTransactionResultFromJSON(json) {
  return EvmTransactionResultFromJSONTyped(json, false);
}
function EvmTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reversion": EvmReversionFromJSON(json["reversion"]),
    "gasDebit": GasDebitFromJSON(json["gas_debit"]),
    "effects": EvmEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/EvmTransactionStateChange.ts
function EvmTransactionStateChangeFromJSON(json) {
  return EvmTransactionStateChangeFromJSONTyped(json, false);
}
function EvmTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "prices": EvmPricesFromJSON(json["prices"]),
    "previousState": !exists(json, "previous_state") ? void 0 : EvmTransactionStateFromJSON(json["previous_state"]),
    "newState": EvmTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/EvmTransaction.ts
function EvmTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "evmTransactionTypeDetails": EvmTransactionEvmTransactionTypeDetailsFromJSON(json["evm_transaction_type_details"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "from": EnrichedEvmAddressFromJSON(json["from"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "value": json["value"],
    "data": json["data"],
    "hexData": !exists(json, "hex_data") ? void 0 : json["hex_data"],
    "parsedData": EvmTransactionParsedDataFromJSON(json["parsed_data"]),
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "nonce": !exists(json, "nonce") ? void 0 : json["nonce"],
    "block": !exists(json, "block") ? void 0 : EvmBlockDataFromJSON(json["block"]),
    "expectedResult": !exists(json, "expected_result") ? void 0 : EvmTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": !exists(json, "simulation_status_result") ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : EvmTransactionResultFromJSON(json["mined_result"]),
    "gasSubmitted": EvmTransactionGasSubmittedFromJSON(json["gas_submitted"]),
    "state": EvmTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(EvmTransactionStateChangeFromJSON),
    "parentTransactionId": !exists(json, "parent_transaction_id") ? void 0 : json["parent_transaction_id"],
    "childTransactionId": !exists(json, "child_transaction_id") ? void 0 : json["child_transaction_id"],
    "fundingForTransactionId": !exists(json, "funding_for_transaction_id") ? void 0 : json["funding_for_transaction_id"],
    "fundedByTransactionId": !exists(json, "funded_by_transaction_id") ? void 0 : json["funded_by_transaction_id"],
    "fundedByVault": !exists(json, "funded_by_vault") ? void 0 : VaultRefFromJSON(json["funded_by_vault"]),
    "currentPrecedingPushedToBlockchainTransactionId": !exists(json, "current_preceding_pushed_to_blockchain_transaction_id") ? void 0 : json["current_preceding_pushed_to_blockchain_transaction_id"],
    "isCancelation": json["is_cancelation"],
    "isAcceleration": json["is_acceleration"],
    "useSecureNode": json["use_secure_node"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "rawTransaction": !exists(json, "raw_transaction") ? void 0 : json["raw_transaction"]
  };
}

// src/openapi/models/SolanaMessageStateChange.ts
function SolanaMessageStateChangeFromJSON(json) {
  return SolanaMessageStateChangeFromJSONTyped(json, false);
}
function SolanaMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : SolanaMessageStateFromJSON(json["previous_state"]),
    "newState": SolanaMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/SolanaMessageType.ts
function SolanaMessageTypeFromJSON(json) {
  return SolanaMessageTypeFromJSONTyped(json, false);
}
function SolanaMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaMessage.ts
function SolanaMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "solanaMessageType": SolanaMessageTypeFromJSON(json["solana_message_type"]),
    "state": SolanaMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(SolanaMessageStateChangeFromJSON),
    "stringData": json["string_data"],
    "rawData": json["raw_data"],
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/SuiMessageStateChange.ts
function SuiMessageStateChangeFromJSON(json) {
  return SuiMessageStateChangeFromJSONTyped(json, false);
}
function SuiMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : SuiMessageStateFromJSON(json["previous_state"]),
    "newState": SuiMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/SuiMessageType.ts
function SuiMessageTypeFromJSON(json) {
  return SuiMessageTypeFromJSONTyped(json, false);
}
function SuiMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiMessage.ts
function SuiMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "suiMessageType": SuiMessageTypeFromJSON(json["sui_message_type"]),
    "state": SuiMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(SuiMessageStateChangeFromJSON),
    "stringData": json["string_data"],
    "rawData": json["raw_data"],
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "sender": EnrichedSuiAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/SuiCoinTransferDetails.ts
function SuiCoinTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": EnrichedSuiAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SuiNativeTransferDetails.ts
function SuiNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": EnrichedSuiAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SuiProgrammableTransactionBlockDetails.ts
function SuiProgrammableTransactionBlockDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipients": json["recipients"].map(EnrichedSuiAddressFromJSON)
  };
}

// src/openapi/models/PredictedSuiTransactionSuiTransactionTypeDetails.ts
function PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json) {
  return PredictedSuiTransactionSuiTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedSuiTransactionSuiTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "coin_transfer":
      return { ...SuiCoinTransferDetailsFromJSONTyped(json, true), type: "coin_transfer" };
    case "native_transfer":
      return { ...SuiNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "programmable_transaction_block":
      return { ...SuiProgrammableTransactionBlockDetailsFromJSONTyped(json, true), type: "programmable_transaction_block" };
    default:
      throw new Error(`No variant of PredictedSuiTransactionSuiTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SuiCheckpointData.ts
function SuiCheckpointDataFromJSON(json) {
  return SuiCheckpointDataFromJSONTyped(json, false);
}
function SuiCheckpointDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "sequenceNumber": json["sequence_number"],
    "digest": json["digest"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/SuiMessageVersion.ts
function SuiMessageVersionFromJSON(json) {
  return SuiMessageVersionFromJSONTyped(json, false);
}
function SuiMessageVersionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiBalanceChangeEffectType.ts
function SuiBalanceChangeEffectTypeFromJSON(json) {
  return SuiBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function SuiBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiBalanceChangeEffect.ts
function SuiBalanceChangeEffectFromJSON(json) {
  return SuiBalanceChangeEffectFromJSONTyped(json, false);
}
function SuiBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": SuiBalanceChangeEffectTypeFromJSON(json["type"]),
    "owner": !exists(json, "owner") ? void 0 : EnrichedSuiAddressFromJSON(json["owner"]),
    "address": EnrichedSuiAddressFromJSON(json["address"])
  };
}

// src/openapi/models/SuiTransferEffectType.ts
function SuiTransferEffectTypeFromJSON(json) {
  return SuiTransferEffectTypeFromJSONTyped(json, false);
}
function SuiTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiTransferEffect.ts
function SuiTransferEffectFromJSON(json) {
  return SuiTransferEffectFromJSONTyped(json, false);
}
function SuiTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": SuiTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedSuiAddressFromJSON(json["from"]),
    "to": EnrichedSuiAddressFromJSON(json["to"])
  };
}

// src/openapi/models/SuiEffects.ts
function SuiEffectsFromJSON(json) {
  return SuiEffectsFromJSONTyped(json, false);
}
function SuiEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(SuiBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(SuiTransferEffectFromJSON)
  };
}

// src/openapi/models/SuiGas.ts
function SuiGasFromJSON(json) {
  return SuiGasFromJSONTyped(json, false);
}
function SuiGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "totalGas": json["total_gas"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/SuiReversionState.ts
function SuiReversionStateFromJSON(json) {
  return SuiReversionStateFromJSONTyped(json, false);
}
function SuiReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiReversion.ts
function SuiReversionFromJSON(json) {
  return SuiReversionFromJSONTyped(json, false);
}
function SuiReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": SuiReversionStateFromJSON(json["state"]),
    "reason": !exists(json, "reason") ? void 0 : json["reason"]
  };
}

// src/openapi/models/SuiTransactionResult.ts
function SuiTransactionResultFromJSON(json) {
  return SuiTransactionResultFromJSONTyped(json, false);
}
function SuiTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reversion": SuiReversionFromJSON(json["reversion"]),
    "transactionError": !exists(json, "transaction_error") ? void 0 : json["transaction_error"],
    "enrichedGas": SuiGasFromJSON(json["enriched_gas"]),
    "effects": SuiEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/SuiTransactionStateChange.ts
function SuiTransactionStateChangeFromJSON(json) {
  return SuiTransactionStateChangeFromJSONTyped(json, false);
}
function SuiTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : SuiTransactionStateFromJSON(json["previous_state"]),
    "newState": SuiTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/SuiTransaction.ts
function SuiTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "suiTransactionTypeDetails": PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json["sui_transaction_type_details"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "state": SuiTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(SuiTransactionStateChangeFromJSON),
    "version": SuiMessageVersionFromJSON(json["version"]),
    "inputs": json["inputs"].map(SuiInputFromJSON),
    "commands": json["commands"].map(SuiCommandFromJSON),
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": !exists(json, "recipient") ? void 0 : EnrichedSuiAddressFromJSON(json["recipient"]),
    "digest": !exists(json, "digest") ? void 0 : json["digest"],
    "txBytes": !exists(json, "tx_bytes") ? void 0 : json["tx_bytes"],
    "checkpoint": !exists(json, "checkpoint") ? void 0 : SuiCheckpointDataFromJSON(json["checkpoint"]),
    "epoch": !exists(json, "epoch") ? void 0 : json["epoch"],
    "gasSubmitted": SuiGasConfigFromJSON(json["gas_submitted"]),
    "expectedResult": !exists(json, "expected_result") ? void 0 : SuiTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : SuiTransactionResultFromJSON(json["mined_result"]),
    "transactionBlockData": !exists(json, "transaction_block_data") ? void 0 : json["transaction_block_data"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/TonMessageStateChange.ts
function TonMessageStateChangeFromJSON(json) {
  return TonMessageStateChangeFromJSONTyped(json, false);
}
function TonMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : TonMessageStateFromJSON(json["previous_state"]),
    "newState": TonMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/TonMessageType.ts
function TonMessageTypeFromJSON(json) {
  return TonMessageTypeFromJSONTyped(json, false);
}
function TonMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TonMessage.ts
function TonMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "tonMessageType": TonMessageTypeFromJSON(json["ton_message_type"]),
    "state": TonMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(TonMessageStateChangeFromJSON),
    "rawPayloadToSign": json["raw_payload_to_sign"],
    "stringPayloadToSign": json["string_payload_to_sign"],
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "domain": json["domain"],
    "domainBytesLength": json["domain_bytes_length"],
    "timestamp": json["timestamp"]
  };
}

// src/openapi/models/TonJettonTransferDetails.ts
function TonJettonTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "recipient": EnrichedTonAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TonNativeTransferDetails.ts
function TonNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "recipient": EnrichedTonAddressFromJSON(json["recipient"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TonRawTransactionDetails.ts
function TonRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipients": json["recipients"].map(EnrichedTonAddressFromJSON)
  };
}

// src/openapi/models/PredictedTonTransactionTonTransactionTypeDetails.ts
function PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json) {
  return PredictedTonTransactionTonTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedTonTransactionTonTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "jetton_transfer":
      return { ...TonJettonTransferDetailsFromJSONTyped(json, true), type: "jetton_transfer" };
    case "native_transfer":
      return { ...TonNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "raw_transaction":
      return { ...TonRawTransactionDetailsFromJSONTyped(json, true), type: "raw_transaction" };
    default:
      throw new Error(`No variant of PredictedTonTransactionTonTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/TonBlock.ts
function TonBlockFromJSON(json) {
  return TonBlockFromJSONTyped(json, false);
}
function TonBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "sequence": json["sequence"],
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/TonAddressFee.ts
function TonAddressFeeFromJSON(json) {
  return TonAddressFeeFromJSONTyped(json, false);
}
function TonAddressFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EnrichedTonAddressFromJSON(json["address"]),
    "totalFee": json["total_fee"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/TonBalanceChangeEffect.ts
function TonBalanceChangeEffectFromJSON(json) {
  return TonBalanceChangeEffectFromJSONTyped(json, false);
}
function TonBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedTonAddressFromJSON(json["address"])
  };
}

// src/openapi/models/TonTransferEffect.ts
function TonTransferEffectFromJSON(json) {
  return TonTransferEffectFromJSONTyped(json, false);
}
function TonTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedTonAddressFromJSON(json["from"]),
    "to": EnrichedTonAddressFromJSON(json["to"])
  };
}

// src/openapi/models/TonEffects.ts
function TonEffectsFromJSON(json) {
  return TonEffectsFromJSONTyped(json, false);
}
function TonEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(TonBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(TonTransferEffectFromJSON)
  };
}

// src/openapi/models/TonReversionState.ts
function TonReversionStateFromJSON(json) {
  return TonReversionStateFromJSONTyped(json, false);
}
function TonReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TonReversion.ts
function TonReversionFromJSON(json) {
  return TonReversionFromJSONTyped(json, false);
}
function TonReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "state": TonReversionStateFromJSON(json["state"]),
    "reason": !exists(json, "reason") ? void 0 : json["reason"]
  };
}

// src/openapi/models/TonTransactionResult.ts
function TonTransactionResultFromJSON(json) {
  return TonTransactionResultFromJSONTyped(json, false);
}
function TonTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reversion": TonReversionFromJSON(json["reversion"]),
    "addressFees": json["address_fees"].map(TonAddressFeeFromJSON),
    "effects": TonEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/TonTransactionStateChange.ts
function TonTransactionStateChangeFromJSON(json) {
  return TonTransactionStateChangeFromJSONTyped(json, false);
}
function TonTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : TonTransactionStateFromJSON(json["previous_state"]),
    "newState": TonTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/TonTransaction.ts
function TonTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "tonTransactionTypeDetails": PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json["ton_transaction_type_details"]),
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "state": TonTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(TonTransactionStateChangeFromJSON),
    "nonce": !exists(json, "nonce") ? void 0 : json["nonce"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "payload": TonTransactionPayloadFromJSON(json["payload"]),
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "block": !exists(json, "block") ? void 0 : TonBlockFromJSON(json["block"]),
    "serializedSignedTransaction": !exists(json, "serialized_signed_transaction") ? void 0 : json["serialized_signed_transaction"],
    "expectedResult": !exists(json, "expected_result") ? void 0 : TonTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": !exists(json, "simulation_status_result") ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : TonTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/UtxoMessageState.ts
function UtxoMessageStateFromJSON(json) {
  return UtxoMessageStateFromJSONTyped(json, false);
}
function UtxoMessageStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoMessageStateToJSON(value) {
  return value;
}

// src/openapi/models/UtxoMessageStateChange.ts
function UtxoMessageStateChangeFromJSON(json) {
  return UtxoMessageStateChangeFromJSONTyped(json, false);
}
function UtxoMessageStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : UtxoMessageStateFromJSON(json["previous_state"]),
    "newState": UtxoMessageStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/UtxoMessage.ts
function UtxoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "utxoMessageType": UtxoMessageTypeFromJSON(json["utxo_message_type"]),
    "rawData": json["raw_data"],
    "state": UtxoMessageStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(UtxoMessageStateChangeFromJSON),
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "stringData": json["string_data"],
    "sender": EnrichedUtxoAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/UtxoNativeTransferDetails.ts
function UtxoNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "isInternal": !exists(json, "is_internal") ? void 0 : json["is_internal"],
    "vault": !exists(json, "vault") ? void 0 : VaultRefFromJSON(json["vault"])
  };
}

// src/openapi/models/UtxoPsbtDetails.ts
function UtxoPsbtDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "psbtRawData": json["psbt_raw_data"],
    "signedPsbtRawData": !exists(json, "signed_psbt_raw_data") ? void 0 : json["signed_psbt_raw_data"],
    "sender": EnrichedUtxoAddressFromJSON(json["sender"]),
    "jsonRepresentation": !exists(json, "json_representation") ? void 0 : json["json_representation"]
  };
}

// src/openapi/models/PredictedUtxoTransactionUtxoTransactionTypeDetails.ts
function PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json) {
  return PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return { ...UtxoNativeTransferDetailsFromJSONTyped(json, true), type: "native_transfer" };
    case "partially_signed_bitcoin_transaction":
      return { ...UtxoPsbtDetailsFromJSONTyped(json, true), type: "partially_signed_bitcoin_transaction" };
    default:
      throw new Error(`No variant of PredictedUtxoTransactionUtxoTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/UtxoBlockData.ts
function UtxoBlockDataFromJSON(json) {
  return UtxoBlockDataFromJSONTyped(json, false);
}
function UtxoBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/UtxoBalanceChangeEffect.ts
function UtxoBalanceChangeEffectFromJSON(json) {
  return UtxoBalanceChangeEffectFromJSONTyped(json, false);
}
function UtxoBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "vault": VaultRefFromJSON(json["vault"]),
    "diff": json["diff"],
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UtxoInput.ts
function UtxoInputFromJSON(json) {
  return UtxoInputFromJSONTyped(json, false);
}
function UtxoInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EnrichedUtxoAddressFromJSON(json["address"]),
    "value": json["value"],
    "shouldSign": !exists(json, "should_sign") ? void 0 : json["should_sign"]
  };
}

// src/openapi/models/UtxoOutput.ts
function UtxoOutputFromJSON(json) {
  return UtxoOutputFromJSONTyped(json, false);
}
function UtxoOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": EnrichedUtxoAddressFromJSON(json["address"]),
    "value": json["value"],
    "isChangeAddress": !exists(json, "is_change_address") ? void 0 : json["is_change_address"]
  };
}

// src/openapi/models/UtxoEffects.ts
function UtxoEffectsFromJSON(json) {
  return UtxoEffectsFromJSONTyped(json, false);
}
function UtxoEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "inputs": json["inputs"].map(UtxoInputFromJSON),
    "outputs": json["outputs"].map(UtxoOutputFromJSON),
    "balanceChanges": json["balance_changes"].map(UtxoBalanceChangeEffectFromJSON),
    "totalValue": json["total_value"],
    "price": !exists(json, "price") ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/FeePriorityLevel.ts
function FeePriorityLevelFromJSON(json) {
  return FeePriorityLevelFromJSONTyped(json, false);
}
function FeePriorityLevelFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/UtxoFees.ts
function UtxoFeesFromJSON(json) {
  return UtxoFeesFromJSONTyped(json, false);
}
function UtxoFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "priority": FeePriorityLevelFromJSON(json["priority"]),
    "feePerByte": json["fee_per_byte"],
    "totalFee": json["total_fee"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/UtxoTransactionResult.ts
function UtxoTransactionResultFromJSON(json) {
  return UtxoTransactionResultFromJSONTyped(json, false);
}
function UtxoTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "fees": !exists(json, "fees") ? void 0 : UtxoFeesFromJSON(json["fees"]),
    "effects": UtxoEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/UtxoTransactionState.ts
function UtxoTransactionStateFromJSON(json) {
  return UtxoTransactionStateFromJSONTyped(json, false);
}
function UtxoTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/UtxoTransactionStateChange.ts
function UtxoTransactionStateChangeFromJSON(json) {
  return UtxoTransactionStateChangeFromJSONTyped(json, false);
}
function UtxoTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": !exists(json, "reason") ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"].map(PricedAssetFromJSON),
    "previousState": !exists(json, "previous_state") ? void 0 : UtxoTransactionStateFromJSON(json["previous_state"]),
    "newState": UtxoTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/UtxoTransaction.ts
function UtxoTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": !exists(json, "managed_transaction_data") ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": !exists(json, "note") ? void 0 : json["note"],
    "spamState": !exists(json, "spam_state") ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "type": json["type"],
    "utxoTransactionTypeDetails": PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json["utxo_transaction_type_details"]),
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "hash": !exists(json, "hash") ? void 0 : json["hash"],
    "explorerUrl": !exists(json, "explorer_url") ? void 0 : json["explorer_url"],
    "state": UtxoTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(UtxoTransactionStateChangeFromJSON),
    "block": !exists(json, "block") ? void 0 : UtxoBlockDataFromJSON(json["block"]),
    "expectedResult": !exists(json, "expected_result") ? void 0 : UtxoTransactionResultFromJSON(json["expected_result"]),
    "minedResult": !exists(json, "mined_result") ? void 0 : UtxoTransactionResultFromJSON(json["mined_result"])
  };
}

// src/openapi/models/CreateTransactionResponse.ts
function CreateTransactionResponseFromJSON(json) {
  return CreateTransactionResponseFromJSONTyped(json, false);
}
function CreateTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of CreateTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/CreateUtxoMessageWithWaitRequest.ts
function CreateUtxoMessageWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": UtxoMessageDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": UtxoMessageStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateUtxoTransactionWithWaitRequest.ts
function CreateUtxoTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "note": value.note,
    "signer_type": SignerTypeToJSON(value.signerType),
    "sign_mode": SignModeToJSON(value.signMode),
    "type": value.type,
    "details": CreateUtxoTransactionRequestDetailsToJSON(value.details),
    "timeout": value.timeout,
    "wait_for_state": UtxoTransactionStateToJSON(value.waitForState)
  };
}

// src/openapi/models/CreateTransactionWithWaitRequest.ts
function CreateTransactionWithWaitRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos_message":
      return CreateAptosMessageWithWaitRequestToJSON(value);
    case "aptos_transaction":
      return CreateAptosTransactionWithWaitRequestToJSON(value);
    case "black_box_signature":
      return CreateBlackBoxSignatureWithWaitRequestToJSON(value);
    case "cosmos_message":
      return CreateCosmosMessageWithWaitRequestToJSON(value);
    case "cosmos_transaction":
      return CreateCosmosTransactionWithWaitRequestToJSON(value);
    case "evm_message":
      return CreateEvmMessageWithWaitRequestToJSON(value);
    case "evm_transaction":
      return CreateEvmTransactionWithWaitRequestToJSON(value);
    case "solana_message":
      return CreateSolanaMessageWithWaitRequestToJSON(value);
    case "solana_transaction":
      return CreateSolanaTransactionWithWaitRequestToJSON(value);
    case "sui_message":
      return CreateSuiMessageWithWaitRequestToJSON(value);
    case "sui_transaction":
      return CreateSuiTransactionWithWaitRequestToJSON(value);
    case "ton_message":
      return CreateTonMessageWithWaitRequestToJSON(value);
    case "ton_transaction":
      return CreateTonTransactionWithWaitRequestToJSON(value);
    case "utxo_message":
      return CreateUtxoMessageWithWaitRequestToJSON(value);
    case "utxo_transaction":
      return CreateUtxoTransactionWithWaitRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateTransactionWithWaitRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTransactionWithWaitResponseState.ts
function CreateTransactionWithWaitResponseStateFromJSON(json) {
  return CreateTransactionWithWaitResponseStateFromJSONTyped(json, false);
}
function CreateTransactionWithWaitResponseStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CreateTransactionWithWaitResponse.ts
function CreateTransactionWithWaitResponseFromJSON(json) {
  return CreateTransactionWithWaitResponseFromJSONTyped(json, false);
}
function CreateTransactionWithWaitResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "signatures": json["signatures"],
    "state": CreateTransactionWithWaitResponseStateFromJSON(json["state"]),
    "hasTimedOut": json["has_timed_out"]
  };
}

// src/openapi/models/CreateUtxoVaultRequest.ts
function CreateUtxoVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "keyset_id": value.keysetId,
    "end_user_id": value.endUserId,
    "vault_group_id": value.vaultGroupId,
    "import_vault": ImportVaultOptionsToJSON(value.importVault),
    "type": value.type,
    "chain": UtxoChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/CreateVaultRequest.ts
function CreateVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos":
      return CreateAptosVaultRequestToJSON(value);
    case "black_box":
      return CreateBlackBoxVaultRequestToJSON(value);
    case "cosmos":
      return CreateCosmosVaultRequestToJSON(value);
    case "evm":
      return CreateEvmVaultRequestToJSON(value);
    case "solana":
      return CreateSolanaVaultRequestToJSON(value);
    case "sui":
      return CreateSuiVaultRequestToJSON(value);
    case "ton":
      return CreateTonVaultRequestToJSON(value);
    case "utxo":
      return CreateUtxoVaultRequestToJSON(value);
    default:
      throw new Error(`No variant of CreateVaultRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateVaultResponse.ts
function CreateVaultResponseFromJSON(json) {
  return CreateVaultResponseFromJSONTyped(json, false);
}
function CreateVaultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return { ...AptosVaultFromJSONTyped(json, true), type: "aptos" };
    case "black_box":
      return { ...BlackBoxVaultFromJSONTyped(json, true), type: "black_box" };
    case "cosmos":
      return { ...CosmosVaultFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EvmVaultFromJSONTyped(json, true), type: "evm" };
    case "exchange":
      return { ...ExchangeVaultFromJSONTyped(json, true), type: "exchange" };
    case "solana":
      return { ...SolanaVaultFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...SuiVaultFromJSONTyped(json, true), type: "sui" };
    case "ton":
      return { ...TonVaultFromJSONTyped(json, true), type: "ton" };
    case "utxo":
      return { ...UtxoVaultFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of CreateVaultResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/DetailsAptosSerializedRawTransactionRequest.ts
function DetailsAptosSerializedRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "gas_config": AptosGasConfigRequestToJSON(value.gasConfig),
    "chain": AptosChainUniqueIdToJSON(value.chain),
    "serialized_transaction_payload": value.serializedTransactionPayload,
    "skip_simulation": value.skipSimulation
  };
}

// src/openapi/models/DetailsAptosTransferRequest.ts
function DetailsAptosTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "gas_config": AptosGasConfigRequestToJSON(value.gasConfig),
    "to": CreateAptosTransferRequestToToJSON(value.to),
    "value": CreateAptosTransferRequestValueToJSON(value.value),
    "asset_identifier": AptosAssetIdentifierRequestToJSON(value.assetIdentifier),
    "skip_simulation": value.skipSimulation
  };
}

// src/openapi/models/DetailsTonSerializedRawTransactionRequest.ts
function DetailsTonSerializedRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "chain": TonChainUniqueIdToJSON(value.chain),
    "transaction_payload": TonTransactionPayloadToJSON(value.transactionPayload),
    "skip_simulation": value.skipSimulation
  };
}

// src/openapi/models/DetailsTonTransferRequest.ts
function DetailsTonTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "push_mode": PushModeToJSON(value.pushMode),
    "to": CreateTonTransferRequestToToJSON(value.to),
    "value": CreateTonTransferRequestValueToJSON(value.value),
    "asset_identifier": TonAssetIdentifierRequestToJSON(value.assetIdentifier),
    "skip_simulation": value.skipSimulation
  };
}

// src/openapi/models/DynamicGasFields.ts
function DynamicGasFieldsFromJSON(json) {
  return DynamicGasFieldsFromJSONTyped(json, false);
}
function DynamicGasFieldsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "maxPriorityFeePerGas": json["max_priority_fee_per_gas"],
    "maxFeePerGas": json["max_fee_per_gas"]
  };
}

// src/openapi/models/EnrichedDapp.ts
function EnrichedDappFromJSON(json) {
  return EnrichedDappFromJSONTyped(json, false);
}
function EnrichedDappFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "url": !exists(json, "url") ? void 0 : json["url"],
    "logoUrl": !exists(json, "logo_url") ? void 0 : json["logo_url"],
    "chain": EnrichedChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmAccountRepr.ts
function EvmAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "hex_repr": value.hexRepr
  };
}

// src/openapi/models/EvmChainId.ts
var EvmChainId = {
  NUMBER_1: 1,
  NUMBER_5: 5,
  NUMBER_10: 10,
  NUMBER_16: 16,
  NUMBER_56: 56,
  NUMBER_100: 100,
  NUMBER_137: 137,
  NUMBER_169: 169,
  NUMBER_250: 250,
  NUMBER_324: 324,
  NUMBER_1030: 1030,
  NUMBER_1100: 1100,
  NUMBER_1101: 1101,
  NUMBER_1329: 1329,
  NUMBER_1729: 1729,
  NUMBER_2222: 2222,
  NUMBER_4200: 4200,
  NUMBER_5000: 5e3,
  NUMBER_7000: 7e3,
  NUMBER_7700: 7700,
  NUMBER_8453: 8453,
  NUMBER_17000: 17e3,
  NUMBER_80001: 80001,
  NUMBER_42161: 42161,
  NUMBER_43114: 43114,
  NUMBER_59144: 59144,
  NUMBER_81457: 81457,
  NUMBER_421614: 421614,
  NUMBER_534352: 534352,
  NUMBER_660279: 660279,
  NUMBER_810180: 810180,
  NUMBER_11155111: 11155111
};

// src/openapi/models/EvmChainUniqueId.ts
var EvmChainUniqueId = {
  _1: "evm_1",
  _5: "evm_5",
  _10: "evm_10",
  _16: "evm_16",
  _56: "evm_56",
  _100: "evm_100",
  _137: "evm_137",
  _169: "evm_169",
  _250: "evm_250",
  _324: "evm_324",
  _1030: "evm_1030",
  _1100: "evm_1100",
  _1101: "evm_1101",
  _1329: "evm_1329",
  _1729: "evm_1729",
  _2222: "evm_2222",
  _4200: "evm_4200",
  _5000: "evm_5000",
  _7000: "evm_7000",
  _7700: "evm_7700",
  _8453: "evm_8453",
  _17000: "evm_17000",
  _80001: "evm_80001",
  _42161: "evm_42161",
  _43114: "evm_43114",
  _59144: "evm_59144",
  _81457: "evm_81457",
  _421614: "evm_421614",
  _534352: "evm_534352",
  _660279: "evm_660279",
  _810180: "evm_810180",
  _11155111: "evm_11155111",
  ethereumMainnet: "evm_ethereum_mainnet",
  ethereumGoerli: "evm_ethereum_goerli",
  optimismMainnet: "evm_optimism_mainnet",
  flareTestnet: "evm_flare_testnet",
  bscMainnet: "evm_bsc_mainnet",
  gnosisMainnet: "evm_gnosis_mainnet",
  polygonMainnet: "evm_polygon_mainnet",
  mantaPacificMainnet: "evm_manta_pacific_mainnet",
  fantomMainnet: "evm_fantom_mainnet",
  zksyncEraMainnet: "evm_zksync_era_mainnet",
  confluxMainnet: "evm_conflux_mainnet",
  dymensionMainnet: "evm_dymension_mainnet",
  polygonZkevmMainnet: "evm_polygon_zkevm_mainnet",
  seiMainnet: "evm_sei_mainnet",
  reyaMainnet: "evm_reya_mainnet",
  kavaMainnet: "evm_kava_mainnet",
  merlinMainnet: "evm_merlin_mainnet",
  mantleMainnet: "evm_mantle_mainnet",
  zetaMainnet: "evm_zeta_mainnet",
  cantoMainnet: "evm_canto_mainnet",
  baseMainnet: "evm_base_mainnet",
  ethereumHolesky: "evm_ethereum_holesky",
  polygonMumbai: "evm_polygon_mumbai",
  arbitrumMainnet: "evm_arbitrum_mainnet",
  avalancheChain: "evm_avalanche_chain",
  lineaMainnet: "evm_linea_mainnet",
  blastMainnet: "evm_blast_mainnet",
  arbitrumSepolia: "evm_arbitrum_sepolia",
  scrollMainnet: "evm_scroll_mainnet",
  xaiMainnet: "evm_xai_mainnet",
  zklinkNovaMainnet: "evm_zklink_nova_mainnet",
  ethereumSepolia: "evm_ethereum_sepolia"
};

// src/openapi/models/EvmDynamicSuggestedFees.ts
function EvmDynamicSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": DynamicGasFieldsFromJSON(json["low"]),
    "medium": DynamicGasFieldsFromJSON(json["medium"]),
    "high": DynamicGasFieldsFromJSON(json["high"])
  };
}

// src/openapi/models/EvmGasEstimation.ts
function EvmGasEstimationFromJSON(json) {
  return EvmGasEstimationFromJSONTyped(json, false);
}
function EvmGasEstimationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "gasLimit": json["gas_limit"],
    "fiatPrice": !exists(json, "fiat_price") ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/LegacyGasFields.ts
function LegacyGasFieldsFromJSON(json) {
  return LegacyGasFieldsFromJSONTyped(json, false);
}
function LegacyGasFieldsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "price": json["price"]
  };
}

// src/openapi/models/EvmLegacySuggestedFees.ts
function EvmLegacySuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": LegacyGasFieldsFromJSON(json["low"]),
    "medium": LegacyGasFieldsFromJSON(json["medium"]),
    "high": LegacyGasFieldsFromJSON(json["high"])
  };
}

// src/openapi/models/EvmSuggestedFeesFees.ts
function EvmSuggestedFeesFeesFromJSON(json) {
  return EvmSuggestedFeesFeesFromJSONTyped(json, false);
}
function EvmSuggestedFeesFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "dynamic":
      return { ...EvmDynamicSuggestedFeesFromJSONTyped(json, true), type: "dynamic" };
    case "legacy":
      return { ...EvmLegacySuggestedFeesFromJSONTyped(json, true), type: "legacy" };
    default:
      throw new Error(`No variant of EvmSuggestedFeesFees exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmSuggestedFees.ts
function EvmSuggestedFeesFromJSON(json) {
  return EvmSuggestedFeesFromJSONTyped(json, false);
}
function EvmSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "fees": EvmSuggestedFeesFeesFromJSON(json["fees"]),
    "chainUniqueId": json["chain_unique_id"]
  };
}

// src/openapi/models/Transaction.ts
function TransactionFromJSON(json) {
  return TransactionFromJSONTyped(json, false);
}
function TransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of Transaction exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GetNextApiSignerTransactionResponse.ts
function GetNextApiSignerTransactionResponseFromJSON(json) {
  return GetNextApiSignerTransactionResponseFromJSONTyped(json, false);
}
function GetNextApiSignerTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transaction": !exists(json, "transaction") ? void 0 : TransactionFromJSON(json["transaction"])
  };
}

// src/openapi/models/TransactionType.ts
function TransactionTypeFromJSON(json) {
  return TransactionTypeFromJSONTyped(json, false);
}
function TransactionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/GetNextApiSignerTransactionResponseV2Body.ts
function GetNextApiSignerTransactionResponseV2BodyFromJSON(json) {
  return GetNextApiSignerTransactionResponseV2BodyFromJSONTyped(json, false);
}
function GetNextApiSignerTransactionResponseV2BodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionId": json["transaction_id"],
    "transactionType": TransactionTypeFromJSON(json["transaction_type"])
  };
}

// src/openapi/models/GetNextApiSignerTransactionResponseV2.ts
function GetNextApiSignerTransactionResponseV2FromJSON(json) {
  return GetNextApiSignerTransactionResponseV2FromJSONTyped(json, false);
}
function GetNextApiSignerTransactionResponseV2FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "body": !exists(json, "body") ? void 0 : GetNextApiSignerTransactionResponseV2BodyFromJSON(json["body"])
  };
}

// src/openapi/models/GetRpcEndpointsResponse.ts
function GetRpcEndpointsResponseFromJSON(json) {
  return GetRpcEndpointsResponseFromJSONTyped(json, false);
}
function GetRpcEndpointsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "endpointsByChain": json["endpoints_by_chain"]
  };
}

// src/openapi/models/SolanaSuggestedFees.ts
function SolanaSuggestedFeesFromJSON(json) {
  return SolanaSuggestedFeesFromJSONTyped(json, false);
}
function SolanaSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": SolanaChainUniqueIdFromJSON(json["chain_unique_id"]),
    "feePerSignature": json["fee_per_signature"]
  };
}

// src/openapi/models/SuiSuggestedFees.ts
function SuiSuggestedFeesFromJSON(json) {
  return SuiSuggestedFeesFromJSONTyped(json, false);
}
function SuiSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": SuiChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/TonSuggestedFees.ts
function TonSuggestedFeesFromJSON(json) {
  return TonSuggestedFeesFromJSONTyped(json, false);
}
function TonSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": TonChainUniqueIdFromJSON(json["chain_unique_id"]),
    "gasPrice": json["gas_price"]
  };
}

// src/openapi/models/UtxoSuggestedFees.ts
function UtxoSuggestedFeesFromJSON(json) {
  return UtxoSuggestedFeesFromJSONTyped(json, false);
}
function UtxoSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"],
    "chainUniqueId": UtxoChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/SuggestedFees.ts
function SuggestedFeesFromJSON(json) {
  return SuggestedFeesFromJSONTyped(json, false);
}
function SuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return { ...AptosSuggestedFeesFromJSONTyped(json, true), type: "aptos" };
    case "cosmos":
      return { ...CosmosSuggestedFeesFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EvmSuggestedFeesFromJSONTyped(json, true), type: "evm" };
    case "solana":
      return { ...SolanaSuggestedFeesFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...SuiSuggestedFeesFromJSONTyped(json, true), type: "sui" };
    case "ton":
      return { ...TonSuggestedFeesFromJSONTyped(json, true), type: "ton" };
    case "utxo":
      return { ...UtxoSuggestedFeesFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of SuggestedFees exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GetSuggestedFeesResponse.ts
function GetSuggestedFeesResponseFromJSON(json) {
  return GetSuggestedFeesResponseFromJSONTyped(json, false);
}
function GetSuggestedFeesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "suggestedFees": mapValues(json["suggested_fees"], SuggestedFeesFromJSON)
  };
}

// src/openapi/models/GetTransactionResponse.ts
function GetTransactionResponseFromJSON(json) {
  return GetTransactionResponseFromJSONTyped(json, false);
}
function GetTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of GetTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GetVaultResponse.ts
function GetVaultResponseFromJSON(json) {
  return GetVaultResponseFromJSONTyped(json, false);
}
function GetVaultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return { ...AptosVaultFromJSONTyped(json, true), type: "aptos" };
    case "black_box":
      return { ...BlackBoxVaultFromJSONTyped(json, true), type: "black_box" };
    case "cosmos":
      return { ...CosmosVaultFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EvmVaultFromJSONTyped(json, true), type: "evm" };
    case "exchange":
      return { ...ExchangeVaultFromJSONTyped(json, true), type: "exchange" };
    case "solana":
      return { ...SolanaVaultFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...SuiVaultFromJSONTyped(json, true), type: "sui" };
    case "ton":
      return { ...TonVaultFromJSONTyped(json, true), type: "ton" };
    case "utxo":
      return { ...UtxoVaultFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of GetVaultResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/KeyDerivationArgs.ts
function KeyDerivationArgsFromJSON(json) {
  return KeyDerivationArgsFromJSONTyped(json, false);
}
function KeyDerivationArgsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keyType": KeyTypeFromJSON(json["key_type"]),
    "coinType": json["coin_type"],
    "accountId": json["account_id"],
    "addressIndex": json["address_index"],
    "derivationPath": json["derivation_path"],
    "keysetId": json["keyset_id"],
    "adjustScalar": !exists(json, "adjust_scalar") ? void 0 : json["adjust_scalar"]
  };
}

// src/openapi/models/ListBlockchainsResponse.ts
function ListBlockchainsResponseFromJSON(json) {
  return ListBlockchainsResponseFromJSONTyped(json, false);
}
function ListBlockchainsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "chains": json["chains"].map(EnrichedChainFromJSON)
  };
}

// src/openapi/models/ListDappsResponse.ts
function ListDappsResponseFromJSON(json) {
  return ListDappsResponseFromJSONTyped(json, false);
}
function ListDappsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "dapps": json["dapps"].map(EnrichedDappFromJSON)
  };
}

// src/openapi/models/ListOwnedAssetsResponse.ts
function ListOwnedAssetsResponseFromJSON(json) {
  return ListOwnedAssetsResponseFromJSONTyped(json, false);
}
function ListOwnedAssetsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "ownedAssets": json["owned_assets"].map(OwnedAssetFromJSON)
  };
}

// src/openapi/models/ListTransactionResponse.ts
function ListTransactionResponseFromJSON(json) {
  return ListTransactionResponseFromJSONTyped(json, false);
}
function ListTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "transactions": json["transactions"].map(TransactionFromJSON)
  };
}

// src/openapi/models/SolanaAccountRepr.ts
function SolanaAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "base58_repr": value.base58Repr
  };
}

// src/openapi/models/SuiAccountRepr.ts
function SuiAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "hex_repr": value.hexRepr
  };
}

// src/openapi/models/UtxoAccountRepr.ts
function UtxoAccountReprToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "hex_repr": value.hexRepr
  };
}

// src/openapi/models/MultiChainAccount.ts
function MultiChainAccountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["chainType"]) {
    case "aptos":
      return AptosAccountReprToJSON(value);
    case "cosmos":
      return CosmosAccountReprToJSON(value);
    case "evm":
      return EvmAccountReprToJSON(value);
    case "solana":
      return SolanaAccountReprToJSON(value);
    case "sui":
      return SuiAccountReprToJSON(value);
    case "ton":
      return TonAccountReprToJSON(value);
    case "utxo":
      return UtxoAccountReprToJSON(value);
    default:
      throw new Error(`No variant of MultiChainAccount exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/ListVaultAddressesResponse.ts
function ListVaultAddressesResponseFromJSON(json) {
  return ListVaultAddressesResponseFromJSONTyped(json, false);
}
function ListVaultAddressesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "addresses": json["addresses"].map(UtxoVaultAddressFromJSON)
  };
}

// src/openapi/models/Vault.ts
function VaultFromJSON(json) {
  return VaultFromJSONTyped(json, false);
}
function VaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return { ...AptosVaultFromJSONTyped(json, true), type: "aptos" };
    case "black_box":
      return { ...BlackBoxVaultFromJSONTyped(json, true), type: "black_box" };
    case "cosmos":
      return { ...CosmosVaultFromJSONTyped(json, true), type: "cosmos" };
    case "evm":
      return { ...EvmVaultFromJSONTyped(json, true), type: "evm" };
    case "exchange":
      return { ...ExchangeVaultFromJSONTyped(json, true), type: "exchange" };
    case "solana":
      return { ...SolanaVaultFromJSONTyped(json, true), type: "solana" };
    case "sui":
      return { ...SuiVaultFromJSONTyped(json, true), type: "sui" };
    case "ton":
      return { ...TonVaultFromJSONTyped(json, true), type: "ton" };
    case "utxo":
      return { ...UtxoVaultFromJSONTyped(json, true), type: "utxo" };
    default:
      throw new Error(`No variant of Vault exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/ListVaultsResponse.ts
function ListVaultsResponseFromJSON(json) {
  return ListVaultsResponseFromJSONTyped(json, false);
}
function ListVaultsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "vaults": json["vaults"].map(VaultFromJSON)
  };
}

// src/openapi/models/VaultWithAssets.ts
function VaultWithAssetsFromJSON(json) {
  return VaultWithAssetsFromJSONTyped(json, false);
}
function VaultWithAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "vaultInfo": VaultFromJSON(json["vault_info"]),
    "totalValue": FiatValueFromJSON(json["total_value"]),
    "hasMoreAssets": json["has_more_assets"],
    "ownedAssets": json["owned_assets"].map(OwnedAssetFromJSON),
    "chains": json["chains"].map(EnrichedChainFromJSON),
    "chainsWithAssets": json["chains_with_assets"].map(ChainWithAssetsFromJSON),
    "ownedAssetsCount": json["owned_assets_count"]
  };
}

// src/openapi/models/ListVaultsWithAssetsResponse.ts
function ListVaultsWithAssetsResponseFromJSON(json) {
  return ListVaultsWithAssetsResponseFromJSONTyped(json, false);
}
function ListVaultsWithAssetsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "vaults": json["vaults"].map(VaultWithAssetsFromJSON)
  };
}

// src/openapi/models/NextApiSignerTransactionRequestV3.ts
function NextApiSignerTransactionRequestV3ToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "protocol_version": value.protocolVersion,
    "session_seed": value.sessionSeed
  };
}

// src/openapi/models/SignSession.ts
function SignSessionFromJSON(json) {
  return SignSessionFromJSONTyped(json, false);
}
function SignSessionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "sessionId": json["session_id"],
    "payloadToSign": json["payload_to_sign"],
    "keyDerivationArgs": KeyDerivationArgsFromJSON(json["key_derivation_args"])
  };
}

// src/openapi/models/RegisterTransactionSignSessionResponse.ts
function RegisterTransactionSignSessionResponseFromJSON(json) {
  return RegisterTransactionSignSessionResponseFromJSONTyped(json, false);
}
function RegisterTransactionSignSessionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "sessionId": json["session_id"],
    "hash": json["hash"],
    "timestampedSignature": TimestampedSignatureFromJSON(json["timestamped_signature"]),
    "timestampedSignatureV2": TimestampedSignatureFromJSON(json["timestamped_signature_v2"]),
    "keyDerivationArgs": KeyDerivationArgsFromJSON(json["key_derivation_args"]),
    "signSessions": json["sign_sessions"].map(SignSessionFromJSON),
    "dklsEnabled": !exists(json, "dkls_enabled") ? void 0 : json["dkls_enabled"]
  };
}

// src/openapi/models/NextApiSignerTransactionResponseV3Body.ts
function NextApiSignerTransactionResponseV3BodyFromJSON(json) {
  return NextApiSignerTransactionResponseV3BodyFromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV3BodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionId": json["transaction_id"],
    "registerSignInfo": RegisterTransactionSignSessionResponseFromJSON(json["register_sign_info"])
  };
}

// src/openapi/models/NextApiSignerTransactionResponseV3.ts
function NextApiSignerTransactionResponseV3FromJSON(json) {
  return NextApiSignerTransactionResponseV3FromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV3FromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "body": !exists(json, "body") ? void 0 : NextApiSignerTransactionResponseV3BodyFromJSON(json["body"])
  };
}

// src/openapi/models/PredictedSolanaTransaction.ts
function PredictedSolanaTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": SolanaTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "solanaTransactionTypeDetails": PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSON(json["solana_transaction_type_details"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "suggestedFees": SolanaSuggestedFeesFromJSON(json["suggested_fees"]),
    "instructions": json["instructions"].map(SolanaCompiledInstructionFromJSON)
  };
}

// src/openapi/models/TransactionDetailsAptosMessageRequest.ts
function TransactionDetailsAptosMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": AptosPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsAptosTransactionRequestDetails.ts
function TransactionDetailsAptosTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos_serialized_entry_point_payload":
      return DetailsAptosSerializedRawTransactionRequestToJSON(value);
    case "aptos_transfer":
      return DetailsAptosTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsAptosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsAptosTransactionRequest.ts
function TransactionDetailsAptosTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsAptosTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsCosmosMessageRequest.ts
function TransactionDetailsCosmosMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": CosmosArbitraryMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsCosmosTransactionRequest.ts
function TransactionDetailsCosmosTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": CreateCosmosTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsEvmPersonalMessageRequest.ts
function TransactionDetailsEvmPersonalMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": EvmChainRequestToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/TransactionDetailsEvmTypedMessageRequest.ts
function TransactionDetailsEvmTypedMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "chain": EvmChainRequestToJSON(value.chain),
    "raw_data": value.rawData
  };
}

// src/openapi/models/TransactionDetailsEvmMessageRequestDetails.ts
function TransactionDetailsEvmMessageRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "personal_message_type":
      return TransactionDetailsEvmPersonalMessageRequestToJSON(value);
    case "typed_message_type":
      return TransactionDetailsEvmTypedMessageRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsEvmMessageRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsEvmMessageRequest.ts
function TransactionDetailsEvmMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsEvmMessageRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsEvmRawTransactionRequest.ts
function TransactionDetailsEvmRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "chain": EvmChainRequestToJSON(value.chain),
    "to": value.to,
    "value": value.value,
    "data": EvmDataRequestToJSON(value.data)
  };
}

// src/openapi/models/TransactionDetailsEvmRevokeAllowanceRequest.ts
function TransactionDetailsEvmRevokeAllowanceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "chain": EvmChainRequestToJSON(value.chain),
    "token": value.token,
    "spender": value.spender
  };
}

// src/openapi/models/TransactionDetailsEvmTransferRequest.ts
function TransactionDetailsEvmTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "chain": EvmChainRequestToJSON(value.chain),
    "to": CreateEvmTransferRequestToToJSON(value.to),
    "token": value.token,
    "asset_identifier": EvmAssetIdentifierRequestToJSON(value.assetIdentifier),
    "value": CreateEvmTransferRequestValueToJSON(value.value)
  };
}

// src/openapi/models/TransactionDetailsEvmTransactionRequestDetails.ts
function TransactionDetailsEvmTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "evm_raw_transaction":
      return TransactionDetailsEvmRawTransactionRequestToJSON(value);
    case "evm_revoke_allowance":
      return TransactionDetailsEvmRevokeAllowanceRequestToJSON(value);
    case "evm_transfer":
      return TransactionDetailsEvmTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsEvmTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsEvmTransactionRequest.ts
function TransactionDetailsEvmTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsEvmTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsSolanaMessageRequest.ts
function TransactionDetailsSolanaMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": SolanaPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsSolanaRawTransactionRequest.ts
function TransactionDetailsSolanaRawTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": SolanaMessageVersionToJSON(value.version),
    "instructions": value.instructions.map(SolanaCompiledInstructionRequestToJSON),
    "accounts": value.accounts.map(SolanaTransactionAccountRequestToJSON),
    "address_table_lookups": value.addressTableLookups.map(SolanaMessageAddressTableLookupRequestToJSON),
    "signatures": value.signatures === void 0 ? void 0 : value.signatures.map(SolanaTransactionSignaturesRequestToJSON),
    "recent_blockhash": value.recentBlockhash,
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "chain": SolanaChainUniqueIdToJSON(value.chain)
  };
}

// src/openapi/models/TransactionDetailsSolanaTransferRequest.ts
function TransactionDetailsSolanaTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "to": CreateSolanaTransferRequestToToJSON(value.to),
    "value": CreateSolanaTransferRequestValueToJSON(value.value),
    "asset_identifier": SolanaAssetIdentifierRequestToJSON(value.assetIdentifier)
  };
}

// src/openapi/models/TransactionDetailsSolanaTransactionRequestDetails.ts
function TransactionDetailsSolanaTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "solana_raw_transaction":
      return TransactionDetailsSolanaRawTransactionRequestToJSON(value);
    case "solana_transfer":
      return TransactionDetailsSolanaTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsSolanaTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsSolanaTransactionRequest.ts
function TransactionDetailsSolanaTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsSolanaTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsSuiMessageRequest.ts
function TransactionDetailsSuiMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": SuiPersonalMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsSuiProgrammableTransactionBlockRequest.ts
function TransactionDetailsSuiProgrammableTransactionBlockRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "chain": SuiChainUniqueIdToJSON(value.chain),
    "gas_config": SuiGasConfigToJSON(value.gasConfig),
    "inputs": value.inputs.map(SuiInputToJSON),
    "commands": value.commands.map(SuiCommandToJSON)
  };
}

// src/openapi/models/TransactionDetailsSuiTransferRequest.ts
function TransactionDetailsSuiTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "skip_simulation": value.skipSimulation,
    "to": CreateSuiTransferRequestToToJSON(value.to),
    "value": CreateSuiTransferRequestValueToJSON(value.value),
    "asset_identifier": SuiAssetIdentifierRequestToJSON(value.assetIdentifier),
    "gas_config": SuiGasConfigToJSON(value.gasConfig)
  };
}

// src/openapi/models/TransactionDetailsSuiTransactionRequestDetails.ts
function TransactionDetailsSuiTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "sui_programmable_transaction_block":
      return TransactionDetailsSuiProgrammableTransactionBlockRequestToJSON(value);
    case "sui_transfer":
      return TransactionDetailsSuiTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsSuiTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsSuiTransactionRequest.ts
function TransactionDetailsSuiTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsSuiTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsTonMessageRequest.ts
function TransactionDetailsTonMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TonProofMessageRequestToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsTonTransactionRequestDetails.ts
function TransactionDetailsTonTransactionRequestDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "ton_contract_call_payload":
      return DetailsTonSerializedRawTransactionRequestToJSON(value);
    case "ton_transfer":
      return DetailsTonTransferRequestToJSON(value);
    default:
      throw new Error(`No variant of TransactionDetailsTonTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsTonTransactionRequest.ts
function TransactionDetailsTonTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": TransactionDetailsTonTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsUtxoMessageRequest.ts
function TransactionDetailsUtxoMessageRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": UtxoMessageDetailsToJSON(value.details)
  };
}

// src/openapi/models/TransactionDetailsUtxoTransactionRequest.ts
function TransactionDetailsUtxoTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "vault_id": value.vaultId,
    "type": value.type,
    "details": CreateUtxoTransactionRequestDetailsToJSON(value.details)
  };
}

// src/openapi/models/PredictTransactionRequest.ts
function PredictTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "aptos_message":
      return TransactionDetailsAptosMessageRequestToJSON(value);
    case "aptos_transaction":
      return TransactionDetailsAptosTransactionRequestToJSON(value);
    case "cosmos_message":
      return TransactionDetailsCosmosMessageRequestToJSON(value);
    case "cosmos_transaction":
      return TransactionDetailsCosmosTransactionRequestToJSON(value);
    case "evm_message":
      return TransactionDetailsEvmMessageRequestToJSON(value);
    case "evm_transaction":
      return TransactionDetailsEvmTransactionRequestToJSON(value);
    case "solana_message":
      return TransactionDetailsSolanaMessageRequestToJSON(value);
    case "solana_transaction":
      return TransactionDetailsSolanaTransactionRequestToJSON(value);
    case "sui_message":
      return TransactionDetailsSuiMessageRequestToJSON(value);
    case "sui_transaction":
      return TransactionDetailsSuiTransactionRequestToJSON(value);
    case "ton_message":
      return TransactionDetailsTonMessageRequestToJSON(value);
    case "ton_transaction":
      return TransactionDetailsTonTransactionRequestToJSON(value);
    case "utxo_message":
      return TransactionDetailsUtxoMessageRequestToJSON(value);
    case "utxo_transaction":
      return TransactionDetailsUtxoTransactionRequestToJSON(value);
    default:
      throw new Error(`No variant of PredictTransactionRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/PredictedAptosMessage.ts
function PredictedAptosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "aptosMessageType": AptosMessageTypeFromJSON(json["aptos_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedAptosTransaction.ts
function PredictedAptosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": AptosTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "payload": AptosTransactionPayloadFromJSON(json["payload"]),
    "aptosTransactionTypeDetails": AptosTransactionAptosTransactionTypeDetailsFromJSON(json["aptos_transaction_type_details"]),
    "suggestedFees": AptosSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedCosmosMessage.ts
function PredictedCosmosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "cosmosMessageType": CosmosMessageTypeFromJSON(json["cosmos_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedCosmosTransaction.ts
function PredictedCosmosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": CosmosTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "cosmosTransactionTypeDetails": CosmosTransactionTypeDetailsFromJSON(json["cosmos_transaction_type_details"]),
    "memo": !exists(json, "memo") ? void 0 : json["memo"],
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "suggestedFees": CosmosSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictedEvmMessage.ts
function PredictedEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"]),
    "evmMessageType": EvmMessageTypeFromJSON(json["evm_message_type"]),
    "typedData": !exists(json, "typed_data") ? void 0 : EvmMessageTypedDataFromJSON(json["typed_data"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedEvmTransaction.ts
function PredictedEvmTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": EvmTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "evmTransactionTypeDetails": EvmTransactionEvmTransactionTypeDetailsFromJSON(json["evm_transaction_type_details"]),
    "parsedData": EvmTransactionParsedDataFromJSON(json["parsed_data"]),
    "gasEstimation": !exists(json, "gas_estimation") ? void 0 : EvmGasEstimationFromJSON(json["gas_estimation"]),
    "suggestedFees": EvmSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "hexData": !exists(json, "hex_data") ? void 0 : json["hex_data"]
  };
}

// src/openapi/models/PredictedSolanaMessage.ts
function PredictedSolanaMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "solanaMessageType": SolanaMessageTypeFromJSON(json["solana_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedSuiMessage.ts
function PredictedSuiMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "suiMessageType": SuiMessageTypeFromJSON(json["sui_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedSuiTransaction.ts
function PredictedSuiTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": SuiTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "suiTransactionTypeDetails": PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json["sui_transaction_type_details"]),
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "suggestedFees": SuiSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictedTonMessage.ts
function PredictedTonMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "tonMessageType": TonMessageTypeFromJSON(json["ton_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedTonTransaction.ts
function PredictedTonTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "expectedResult": TonTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "payload": TonTransactionPayloadFromJSON(json["payload"]),
    "tonTransactionTypeDetails": PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json["ton_transaction_type_details"]),
    "suggestedFees": TonSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedUtxoMessage.ts
function PredictedUtxoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "sender": EnrichedUtxoAddressFromJSON(json["sender"]),
    "utxoMessageType": UtxoMessageTypeFromJSON(json["utxo_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedUtxoTransaction.ts
function PredictedUtxoTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": !exists(json, "approval_request") ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "expectedResult": UtxoTransactionResultFromJSON(json["expected_result"]),
    "utxoTransactionTypeDetails": PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json["utxo_transaction_type_details"]),
    "suggestedFees": UtxoSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictTransactionResponse.ts
function PredictTransactionResponseFromJSON(json) {
  return PredictTransactionResponseFromJSONTyped(json, false);
}
function PredictTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...PredictedAptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...PredictedAptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "cosmos_message":
      return { ...PredictedCosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...PredictedCosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...PredictedEvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...PredictedEvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...PredictedSolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...PredictedSolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...PredictedSuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...PredictedSuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...PredictedTonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...PredictedTonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...PredictedUtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...PredictedUtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of PredictTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PushTransactionRequest.ts
function PushTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "push_data": CosmosPushDataToJSON(value.pushData)
  };
}

// src/openapi/models/PushTransactionResponse.ts
function PushTransactionResponseFromJSON(json) {
  return PushTransactionResponseFromJSONTyped(json, false);
}
function PushTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of PushTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/RegisterTransactionSignSessionRequest.ts
function RegisterTransactionSignSessionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "signature": value.signature,
    "unsigned_message": value.unsignedMessage,
    "protocol_version": value.protocolVersion,
    "session_seed": value.sessionSeed
  };
}

// src/openapi/models/ReleaseType.ts
function ReleaseTypeToJSON(value) {
  return value;
}

// src/openapi/models/ReleaseEvmTransactionRequest.ts
function ReleaseEvmTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "release_type": ReleaseTypeToJSON(value.releaseType),
    "signer_type": SignerTypeToJSON(value.signerType),
    "fail_on_prediction_failure": value.failOnPredictionFailure,
    "note": value.note
  };
}

// src/openapi/models/ReleaseTransactionResponse.ts
function ReleaseTransactionResponseFromJSON(json) {
  return ReleaseTransactionResponseFromJSONTyped(json, false);
}
function ReleaseTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of ReleaseTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/RenameVaultRequest.ts
function RenameVaultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name
  };
}

// src/openapi/models/TestEvmChainRequest.ts
function TestEvmChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rpc_url": value.rpcUrl,
    "chain_type": value.chainType,
    "chain_id": value.chainId
  };
}

// src/openapi/models/TestChainRequest.ts
function TestChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["chainType"]) {
    case "evm":
      return TestEvmChainRequestToJSON(value);
    default:
      throw new Error(`No variant of TestChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/TriggerAutoProtectionRequest.ts
function TriggerAutoProtectionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "account": MultiChainAccountToJSON(value.account),
    "note": value.note
  };
}

// src/openapi/models/UpdateEvmChainRequest.ts
function UpdateEvmChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain_type": value.chainType,
    "chain_id": value.chainId,
    "chain_name": value.chainName,
    "rpc_url": value.rpcUrl,
    "blockchain_explorer_url": value.blockchainExplorerUrl
  };
}

// src/openapi/models/UpdateChainRequest.ts
function UpdateChainRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["chainType"]) {
    case "evm":
      return UpdateEvmChainRequestToJSON(value);
    default:
      throw new Error(`No variant of UpdateChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/UpdateTransactionForSigningResponse.ts
function UpdateTransactionForSigningResponseFromJSON(json) {
  return UpdateTransactionForSigningResponseFromJSONTyped(json, false);
}
function UpdateTransactionForSigningResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return { ...AptosMessageFromJSONTyped(json, true), type: "aptos_message" };
    case "aptos_transaction":
      return { ...AptosTransactionFromJSONTyped(json, true), type: "aptos_transaction" };
    case "black_box_signature":
      return { ...BlackBoxSignatureFromJSONTyped(json, true), type: "black_box_signature" };
    case "cosmos_message":
      return { ...CosmosMessageFromJSONTyped(json, true), type: "cosmos_message" };
    case "cosmos_transaction":
      return { ...CosmosTransactionFromJSONTyped(json, true), type: "cosmos_transaction" };
    case "evm_message":
      return { ...EvmMessageFromJSONTyped(json, true), type: "evm_message" };
    case "evm_transaction":
      return { ...EvmTransactionFromJSONTyped(json, true), type: "evm_transaction" };
    case "solana_message":
      return { ...SolanaMessageFromJSONTyped(json, true), type: "solana_message" };
    case "solana_transaction":
      return { ...SolanaTransactionFromJSONTyped(json, true), type: "solana_transaction" };
    case "sui_message":
      return { ...SuiMessageFromJSONTyped(json, true), type: "sui_message" };
    case "sui_transaction":
      return { ...SuiTransactionFromJSONTyped(json, true), type: "sui_transaction" };
    case "ton_message":
      return { ...TonMessageFromJSONTyped(json, true), type: "ton_message" };
    case "ton_transaction":
      return { ...TonTransactionFromJSONTyped(json, true), type: "ton_transaction" };
    case "utxo_message":
      return { ...UtxoMessageFromJSONTyped(json, true), type: "utxo_message" };
    case "utxo_transaction":
      return { ...UtxoTransactionFromJSONTyped(json, true), type: "utxo_transaction" };
    default:
      throw new Error(`No variant of UpdateTransactionForSigningResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/UpdateTransactionSpamStateRequest.ts
function UpdateTransactionSpamStateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "is_spam": value.isSpam
  };
}

// src/openapi/models/UpdateVaultMetadataRequest.ts
function UpdateVaultMetadataRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "metadata": value.metadata === void 0 ? void 0 : mapValues(value.metadata, AptosVaultMetadataValueToJSON)
  };
}

// src/openapi/models/VaultMetadata.ts
function VaultMetadataFromJSON(json) {
  return VaultMetadataFromJSONTyped(json, false);
}
function VaultMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "masterKeyId": json["master_key_id"],
    "derivationPath": json["derivation_path"]
  };
}

// src/openapi/models/VaultType.ts
var VaultType = {
  aptos: "aptos",
  blackBox: "black_box",
  cosmos: "cosmos",
  evm: "evm",
  solana: "solana",
  sui: "sui",
  ton: "ton",
  utxo: "utxo",
  exchange: "exchange"
};

// src/openapi/apis/BlockchainsApi.ts
var BlockchainsApi = class extends BaseAPI {
  /**
   * add a new custom chain.
   * Add Chain
   */
  async addChainApiV1BlockchainsPostRaw(requestParameters, initOverrides) {
    if (requestParameters.addChainRequest === null || requestParameters.addChainRequest === void 0) {
      throw new RequiredError("addChainRequest", "Required parameter requestParameters.addChainRequest was null or undefined when calling addChainApiV1BlockchainsPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddChainRequestToJSON(requestParameters.addChainRequest)
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * add a new custom chain.
   * Add Chain
   */
  async addChainApiV1BlockchainsPost(requestParameters, initOverrides) {
    const response = await this.addChainApiV1BlockchainsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Issue a custom rpc command.
   * Custom Chain Rpc
   */
  async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters, initOverrides) {
    if (requestParameters.chainId === null || requestParameters.chainId === void 0) {
      throw new RequiredError("chainId", "Required parameter requestParameters.chainId was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost.");
    }
    if (requestParameters.organizationId === null || requestParameters.organizationId === void 0) {
      throw new RequiredError("organizationId", "Required parameter requestParameters.organizationId was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/rpc/evm/custom-chain-rpc/{organization_id}/{chain_id}`.replace(`{${"chain_id"}}`, encodeURIComponent(String(requestParameters.chainId))).replace(`{${"organization_id"}}`, encodeURIComponent(String(requestParameters.organizationId))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * Issue a custom rpc command.
   * Custom Chain Rpc
   */
  async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost(requestParameters, initOverrides) {
    const response = await this.customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Rpc Endpoints
   */
  async getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/rpc-endpoints`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetRpcEndpointsResponseFromJSON(jsonValue));
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Rpc Endpoints
   */
  async getRpcEndpointsApiV1BlockchainsRpcEndpointsGet(initOverrides) {
    const response = await this.getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Suggested Fees
   */
  async getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.chains) {
      queryParameters["chains"] = requestParameters.chains;
    }
    if (requestParameters.chainTypes) {
      queryParameters["chain_types"] = requestParameters.chainTypes;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/suggested-fees`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetSuggestedFeesResponseFromJSON(jsonValue));
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Suggested Fees
   */
  async getSuggestedFeesApiV1BlockchainsSuggestedFeesGet(requestParameters = {}, initOverrides) {
    const response = await this.getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of supported blockchains.
   * List Chains
   */
  async listChainsApiV1BlockchainsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.chainTypes) {
      queryParameters["chain_types"] = requestParameters.chainTypes;
    }
    if (requestParameters.sources) {
      queryParameters["sources"] = requestParameters.sources;
    }
    if (requestParameters.onlyInteractedWith !== void 0) {
      queryParameters["only_interacted_with"] = requestParameters.onlyInteractedWith;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListBlockchainsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of supported blockchains.
   * List Chains
   */
  async listChainsApiV1BlockchainsGet(requestParameters = {}, initOverrides) {
    const response = await this.listChainsApiV1BlockchainsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all supported dapps.
   * List Dapps
   */
  async listDappsApiV1BlockchainsDappsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    if (requestParameters.dappIds) {
      queryParameters["dapp_ids"] = requestParameters.dappIds;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/dapps`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListDappsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all supported dapps.
   * List Dapps
   */
  async listDappsApiV1BlockchainsDappsGet(requestParameters = {}, initOverrides) {
    const response = await this.listDappsApiV1BlockchainsDappsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Test the RPC connection to a custom chain.
   * Test Rpc
   */
  async testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters, initOverrides) {
    if (requestParameters.testChainRequest === null || requestParameters.testChainRequest === void 0) {
      throw new RequiredError("testChainRequest", "Required parameter requestParameters.testChainRequest was null or undefined when calling testRpcApiV1BlockchainsTestRpcPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/test-rpc`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TestChainRequestToJSON(requestParameters.testChainRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Test the RPC connection to a custom chain.
   * Test Rpc
   */
  async testRpcApiV1BlockchainsTestRpcPost(requestParameters, initOverrides) {
    await this.testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters, initOverrides);
  }
  /**
   * update a custom chain.
   * Update Chain
   */
  async updateChainApiV1BlockchainsPutRaw(requestParameters, initOverrides) {
    if (requestParameters.updateChainRequest === null || requestParameters.updateChainRequest === void 0) {
      throw new RequiredError("updateChainRequest", "Required parameter requestParameters.updateChainRequest was null or undefined when calling updateChainApiV1BlockchainsPut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateChainRequestToJSON(requestParameters.updateChainRequest)
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * update a custom chain.
   * Update Chain
   */
  async updateChainApiV1BlockchainsPut(requestParameters, initOverrides) {
    const response = await this.updateChainApiV1BlockchainsPutRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// src/openapi/apis/TransactionsApi.ts
var TransactionsApi = class extends BaseAPI {
  /**
   * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
   * Abort Transaction
   */
  async abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling abortTransactionApiV1TransactionsIdAbortPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/abort`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
   * Abort Transaction
   */
  async abortTransactionApiV1TransactionsIdAbortPost(requestParameters, initOverrides) {
    await this.abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides);
  }
  /**
   * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
   * Approve Transaction
   */
  async approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling approveTransactionApiV1TransactionsIdApprovePost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
   * Approve Transaction
   */
  async approveTransactionApiV1TransactionsIdApprovePost(requestParameters, initOverrides) {
    await this.approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides);
  }
  /**
   * Create a new transaction and wait until transaction reaches given state.
   * Create Transaction And Wait
   */
  async createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides) {
    if (requestParameters.createTransactionWithWaitRequest === null || requestParameters.createTransactionWithWaitRequest === void 0) {
      throw new RequiredError("createTransactionWithWaitRequest", "Required parameter requestParameters.createTransactionWithWaitRequest was null or undefined when calling createTransactionAndWaitApiV1TransactionsCreateAndWaitPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters.xSignature !== void 0 && requestParameters.xSignature !== null) {
      headerParameters["x-signature"] = String(requestParameters.xSignature);
    }
    if (requestParameters.xTimestamp !== void 0 && requestParameters.xTimestamp !== null) {
      headerParameters["x-timestamp"] = String(requestParameters.xTimestamp);
    }
    if (requestParameters.xIdempotenceId !== void 0 && requestParameters.xIdempotenceId !== null) {
      headerParameters["x-idempotence-id"] = String(requestParameters.xIdempotenceId);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/create-and-wait`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateTransactionWithWaitRequestToJSON(requestParameters.createTransactionWithWaitRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateTransactionWithWaitResponseFromJSON(jsonValue));
  }
  /**
   * Create a new transaction and wait until transaction reaches given state.
   * Create Transaction And Wait
   */
  async createTransactionAndWaitApiV1TransactionsCreateAndWaitPost(requestParameters, initOverrides) {
    const response = await this.createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a new transaction.
   * Create Transaction
   */
  async createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides) {
    if (requestParameters.createTransactionRequest === null || requestParameters.createTransactionRequest === void 0) {
      throw new RequiredError("createTransactionRequest", "Required parameter requestParameters.createTransactionRequest was null or undefined when calling createTransactionApiV1TransactionsPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters.xSignature !== void 0 && requestParameters.xSignature !== null) {
      headerParameters["x-signature"] = String(requestParameters.xSignature);
    }
    if (requestParameters.xTimestamp !== void 0 && requestParameters.xTimestamp !== null) {
      headerParameters["x-timestamp"] = String(requestParameters.xTimestamp);
    }
    if (requestParameters.xIdempotenceId !== void 0 && requestParameters.xIdempotenceId !== null) {
      headerParameters["x-idempotence-id"] = String(requestParameters.xIdempotenceId);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateTransactionRequestToJSON(requestParameters.createTransactionRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Create a new transaction.
   * Create Transaction
   */
  async createTransactionApiV1TransactionsPost(requestParameters, initOverrides) {
    const response = await this.createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a CSV-format list of transactions.
   * Export Transactions
   */
  async exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.limit !== void 0) {
      queryParameters["limit"] = requestParameters.limit;
    }
    if (requestParameters.createdBefore !== void 0) {
      queryParameters["created_before"] = requestParameters.createdBefore.toISOString();
    }
    if (requestParameters.createdAfter !== void 0) {
      queryParameters["created_after"] = requestParameters.createdAfter.toISOString();
    }
    if (requestParameters.modifiedAfter !== void 0) {
      queryParameters["modified_after"] = requestParameters.modifiedAfter.toISOString();
    }
    if (requestParameters.vaultIds) {
      queryParameters["vault_ids"] = requestParameters.vaultIds;
    }
    if (requestParameters.chains) {
      queryParameters["chains"] = requestParameters.chains;
    }
    if (requestParameters.initiatorIds) {
      queryParameters["initiator_ids"] = requestParameters.initiatorIds;
    }
    if (requestParameters.types) {
      queryParameters["types"] = requestParameters.types;
    }
    if (requestParameters.subTypes) {
      queryParameters["sub_types"] = requestParameters.subTypes;
    }
    if (requestParameters.signerTypes) {
      queryParameters["signer_types"] = requestParameters.signerTypes;
    }
    if (requestParameters.transactionIds) {
      queryParameters["transaction_ids"] = requestParameters.transactionIds;
    }
    if (requestParameters.endUserIds) {
      queryParameters["end_user_ids"] = requestParameters.endUserIds;
    }
    if (requestParameters.direction !== void 0) {
      queryParameters["direction"] = requestParameters.direction;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * Get a CSV-format list of transactions.
   * Export Transactions
   */
  async exportTransactionsApiV1TransactionsExportGet(requestParameters = {}, initOverrides) {
    const response = await this.exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the first transaction ready for signing by api-signer.
   * Get Next Api Signer Transaction
   */
  async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/next_api_signer_transaction`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Get the first transaction ready for signing by api-signer.
   * Get Next Api Signer Transaction
   */
  async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGet(initOverrides) {
    const response = await this.getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get the first transaction ready for signing by api-signer.
   * Get Next Api Signer Transaction V2
   */
  async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/next_api_signer_transaction_v2`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseV2FromJSON(jsonValue));
  }
  /**
   * Get the first transaction ready for signing by api-signer.
   * Get Next Api Signer Transaction V2
   */
  async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2Get(initOverrides) {
    const response = await this.getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Retrieve transaction details.
   * Get Transaction
   */
  async getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getTransactionApiV1TransactionsIdGet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Retrieve transaction details.
   * Get Transaction
   */
  async getTransactionApiV1TransactionsIdGet(requestParameters, initOverrides) {
    const response = await this.getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all transactions in an organization.
   * List Transactions
   */
  async listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.createdBefore !== void 0) {
      queryParameters["created_before"] = requestParameters.createdBefore.toISOString();
    }
    if (requestParameters.createdAfter !== void 0) {
      queryParameters["created_after"] = requestParameters.createdAfter.toISOString();
    }
    if (requestParameters.modifiedAfter !== void 0) {
      queryParameters["modified_after"] = requestParameters.modifiedAfter.toISOString();
    }
    if (requestParameters.vaultIds) {
      queryParameters["vault_ids"] = requestParameters.vaultIds;
    }
    if (requestParameters.chains) {
      queryParameters["chains"] = requestParameters.chains;
    }
    if (requestParameters.initiatorIds) {
      queryParameters["initiator_ids"] = requestParameters.initiatorIds;
    }
    if (requestParameters.types) {
      queryParameters["types"] = requestParameters.types;
    }
    if (requestParameters.subTypes) {
      queryParameters["sub_types"] = requestParameters.subTypes;
    }
    if (requestParameters.signerTypes) {
      queryParameters["signer_types"] = requestParameters.signerTypes;
    }
    if (requestParameters.transactionIds) {
      queryParameters["transaction_ids"] = requestParameters.transactionIds;
    }
    if (requestParameters.endUserIds) {
      queryParameters["end_user_ids"] = requestParameters.endUserIds;
    }
    if (requestParameters.direction !== void 0) {
      queryParameters["direction"] = requestParameters.direction;
    }
    if (requestParameters.states) {
      queryParameters["states"] = requestParameters.states;
    }
    if (requestParameters.isHidden !== void 0) {
      queryParameters["is_hidden"] = requestParameters.isHidden;
    }
    if (requestParameters.includeFullResponse !== void 0) {
      queryParameters["include_full_response"] = requestParameters.includeFullResponse;
    }
    if (requestParameters.batchIds) {
      queryParameters["batch_ids"] = requestParameters.batchIds;
    }
    if (requestParameters.sortBy) {
      queryParameters["sort_by"] = requestParameters.sortBy;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all transactions in an organization.
   * List Transactions
   */
  async listTransactionsApiV1TransactionsGet(requestParameters = {}, initOverrides) {
    const response = await this.listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Simulate the transaction and changes in token balances, in addition to the fee estimation.
   * Predict Transaction
   */
  async predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides) {
    if (requestParameters.predictTransactionRequest === null || requestParameters.predictTransactionRequest === void 0) {
      throw new RequiredError("predictTransactionRequest", "Required parameter requestParameters.predictTransactionRequest was null or undefined when calling predictTransactionApiV1TransactionsPredictPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/predict`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PredictTransactionRequestToJSON(requestParameters.predictTransactionRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PredictTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Simulate the transaction and changes in token balances, in addition to the fee estimation.
   * Predict Transaction
   */
  async predictTransactionApiV1TransactionsPredictPost(requestParameters, initOverrides) {
    const response = await this.predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V3
   */
  async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides) {
    if (requestParameters.nextApiSignerTransactionRequestV3 === null || requestParameters.nextApiSignerTransactionRequestV3 === void 0) {
      throw new RequiredError("nextApiSignerTransactionRequestV3", "Required parameter requestParameters.nextApiSignerTransactionRequestV3 was null or undefined when calling processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/next_api_signer_transaction_v3`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: NextApiSignerTransactionRequestV3ToJSON(requestParameters.nextApiSignerTransactionRequestV3)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV3FromJSON(jsonValue));
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V3
   */
  async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post(requestParameters, initOverrides) {
    const response = await this.processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Push a transaction to the chain.
   * Push Transaction
   */
  async pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.");
    }
    if (requestParameters.pushTransactionRequest === null || requestParameters.pushTransactionRequest === void 0) {
      throw new RequiredError("pushTransactionRequest", "Required parameter requestParameters.pushTransactionRequest was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/push`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PushTransactionRequestToJSON(requestParameters.pushTransactionRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PushTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Push a transaction to the chain.
   * Push Transaction
   */
  async pushTransactionApiV1TransactionsIdPushPost(requestParameters, initOverrides) {
    const response = await this.pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Register a sign-session for a transaction.
   * Register Transaction Sign Session
   */
  async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.");
    }
    if (requestParameters.registerTransactionSignSessionRequest === null || requestParameters.registerTransactionSignSessionRequest === void 0) {
      throw new RequiredError("registerTransactionSignSessionRequest", "Required parameter requestParameters.registerTransactionSignSessionRequest was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/register-sign-session`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RegisterTransactionSignSessionRequestToJSON(requestParameters.registerTransactionSignSessionRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RegisterTransactionSignSessionResponseFromJSON(jsonValue));
  }
  /**
   * Register a sign-session for a transaction.
   * Register Transaction Sign Session
   */
  async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost(requestParameters, initOverrides) {
    const response = await this.registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Release a transaction.
   * Release Transaction
   */
  async releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.");
    }
    if (requestParameters.body === null || requestParameters.body === void 0) {
      throw new RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters.xSignature !== void 0 && requestParameters.xSignature !== null) {
      headerParameters["x-signature"] = String(requestParameters.xSignature);
    }
    if (requestParameters.xTimestamp !== void 0 && requestParameters.xTimestamp !== null) {
      headerParameters["x-timestamp"] = String(requestParameters.xTimestamp);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/release`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReleaseEvmTransactionRequestToJSON(requestParameters.body)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReleaseTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Release a transaction.
   * Release Transaction
   */
  async releaseTransactionApiV1TransactionsIdReleasePost(requestParameters, initOverrides) {
    const response = await this.releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Submit a signature for a transaction.
   * Submit Transaction Signature
   */
  async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.");
    }
    if (requestParameters.body === null || requestParameters.body === void 0) {
      throw new RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/submit-signature`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * Submit a signature for a transaction.
   * Submit Transaction Signature
   */
  async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost(requestParameters, initOverrides) {
    const response = await this.submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Trigger transaction auto revoke protection.
   * Trigger Auto Revoke Protection
   */
  async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides) {
    if (requestParameters.triggerAutoProtectionRequest === null || requestParameters.triggerAutoProtectionRequest === void 0) {
      throw new RequiredError("triggerAutoProtectionRequest", "Required parameter requestParameters.triggerAutoProtectionRequest was null or undefined when calling triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/trigger-auto-revoke-protection`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TriggerAutoProtectionRequestToJSON(requestParameters.triggerAutoProtectionRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Trigger transaction auto revoke protection.
   * Trigger Auto Revoke Protection
   */
  async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost(requestParameters, initOverrides) {
    await this.triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides);
  }
  /**
   * Trigger transaction signing.
   * Trigger Transaction Signing
   */
  async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/trigger-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Trigger transaction signing.
   * Trigger Transaction Signing
   */
  async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost(requestParameters, initOverrides) {
    await this.triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides);
  }
  /**
   * Update a transaction before signing it.
   * Update Transaction For Signing
   */
  async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.");
    }
    if (requestParameters.body === null || requestParameters.body === void 0) {
      throw new RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/update-for-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UpdateTransactionForSigningResponseFromJSON(jsonValue));
  }
  /**
   * Update a transaction before signing it.
   * Update Transaction For Signing
   */
  async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost(requestParameters, initOverrides) {
    const response = await this.updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update transaction\'s spam state.
   * Update Transaction Spam State
   */
  async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.");
    }
    if (requestParameters.updateTransactionSpamStateRequest === null || requestParameters.updateTransactionSpamStateRequest === void 0) {
      throw new RequiredError("updateTransactionSpamStateRequest", "Required parameter requestParameters.updateTransactionSpamStateRequest was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/update-spam-state`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateTransactionSpamStateRequestToJSON(requestParameters.updateTransactionSpamStateRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Update transaction\'s spam state.
   * Update Transaction Spam State
   */
  async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut(requestParameters, initOverrides) {
    await this.updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides);
  }
};

// src/openapi/apis/VaultsApi.ts
var VaultsApi = class extends BaseAPI {
  /**
   * Add a specific asset to a vault.
   * Add Vault Asset
   */
  async addVaultAssetApiV1VaultsIdAssetsAssetIdPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling addVaultAssetApiV1VaultsIdAssetsAssetIdPost.");
    }
    if (requestParameters.assetId === null || requestParameters.assetId === void 0) {
      throw new RequiredError("assetId", "Required parameter requestParameters.assetId was null or undefined when calling addVaultAssetApiV1VaultsIdAssetsAssetIdPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets/{asset_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters.assetId))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OwnedAssetFromJSON(jsonValue));
  }
  /**
   * Add a specific asset to a vault.
   * Add Vault Asset
   */
  async addVaultAssetApiV1VaultsIdAssetsAssetIdPost(requestParameters, initOverrides) {
    const response = await this.addVaultAssetApiV1VaultsIdAssetsAssetIdPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Archive an existing vault.
   * Archive Vault
   */
  async archiveVaultApiV1VaultsIdArchivePostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling archiveVaultApiV1VaultsIdArchivePost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/archive`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Archive an existing vault.
   * Archive Vault
   */
  async archiveVaultApiV1VaultsIdArchivePost(requestParameters, initOverrides) {
    await this.archiveVaultApiV1VaultsIdArchivePostRaw(requestParameters, initOverrides);
  }
  /**
   * Create a new address.
   * Create Address
   */
  async createAddressApiV1VaultsIdAddressesPostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling createAddressApiV1VaultsIdAddressesPost.");
    }
    if (requestParameters.body === null || requestParameters.body === void 0) {
      throw new RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling createAddressApiV1VaultsIdAddressesPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/addresses`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UtxoVaultAddressFromJSON(jsonValue));
  }
  /**
   * Create a new address.
   * Create Address
   */
  async createAddressApiV1VaultsIdAddressesPost(requestParameters, initOverrides) {
    const response = await this.createAddressApiV1VaultsIdAddressesPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a new vault.
   * Create Vault
   */
  async createVaultApiV1VaultsPostRaw(requestParameters, initOverrides) {
    if (requestParameters.createVaultRequest === null || requestParameters.createVaultRequest === void 0) {
      throw new RequiredError("createVaultRequest", "Required parameter requestParameters.createVaultRequest was null or undefined when calling createVaultApiV1VaultsPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateVaultRequestToJSON(requestParameters.createVaultRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateVaultResponseFromJSON(jsonValue));
  }
  /**
   * Create a new vault.
   * Create Vault
   */
  async createVaultApiV1VaultsPost(requestParameters, initOverrides) {
    const response = await this.createVaultApiV1VaultsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a CSV-format list of balances of all vaults and their assets.
   * Export Vaults With Assets
   */
  async exportVaultsWithAssetsApiV1VaultsExportGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.vaultsIds) {
      queryParameters["vaults_ids"] = requestParameters.vaultsIds;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new TextApiResponse(response);
  }
  /**
   * Get a CSV-format list of balances of all vaults and their assets.
   * Export Vaults With Assets
   */
  async exportVaultsWithAssetsApiV1VaultsExportGet(requestParameters = {}, initOverrides) {
    const response = await this.exportVaultsWithAssetsApiV1VaultsExportGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieve vault details.
   * Get Vault
   */
  async getVaultApiV1VaultsIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getVaultApiV1VaultsIdGet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetVaultResponseFromJSON(jsonValue));
  }
  /**
   * Retrieve vault details.
   * Get Vault
   */
  async getVaultApiV1VaultsIdGet(requestParameters, initOverrides) {
    const response = await this.getVaultApiV1VaultsIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a specific asset in a vault.
   * Get Vault Asset
   */
  async getVaultAssetApiV1VaultsIdAssetsAssetIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getVaultAssetApiV1VaultsIdAssetsAssetIdGet.");
    }
    if (requestParameters.assetId === null || requestParameters.assetId === void 0) {
      throw new RequiredError("assetId", "Required parameter requestParameters.assetId was null or undefined when calling getVaultAssetApiV1VaultsIdAssetsAssetIdGet.");
    }
    const queryParameters = {};
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets/{asset_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters.assetId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OwnedAssetFromJSON(jsonValue));
  }
  /**
   * Get a specific asset in a vault.
   * Get Vault Asset
   */
  async getVaultAssetApiV1VaultsIdAssetsAssetIdGet(requestParameters, initOverrides) {
    const response = await this.getVaultAssetApiV1VaultsIdAssetsAssetIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all assets in a vault.
   * Get Vault Assets
   */
  async getVaultAssetsApiV1VaultsIdAssetsGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getVaultAssetsApiV1VaultsIdAssetsGet.");
    }
    const queryParameters = {};
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.chains) {
      queryParameters["chains"] = requestParameters.chains;
    }
    if (requestParameters.assetIds) {
      queryParameters["asset_ids"] = requestParameters.assetIds;
    }
    if (requestParameters.isHidden !== void 0) {
      queryParameters["is_hidden"] = requestParameters.isHidden;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    if (requestParameters.sortBy) {
      queryParameters["sort_by"] = requestParameters.sortBy;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListOwnedAssetsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all assets in a vault.
   * Get Vault Assets
   */
  async getVaultAssetsApiV1VaultsIdAssetsGet(requestParameters, initOverrides) {
    const response = await this.getVaultAssetsApiV1VaultsIdAssetsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieve extra vault details.
   * Get Vault Metadata
   */
  async getVaultMetadataApiV1VaultsIdMetadataGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getVaultMetadataApiV1VaultsIdMetadataGet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => VaultMetadataFromJSON(jsonValue));
  }
  /**
   * Retrieve extra vault details.
   * Get Vault Metadata
   */
  async getVaultMetadataApiV1VaultsIdMetadataGet(requestParameters, initOverrides) {
    const response = await this.getVaultMetadataApiV1VaultsIdMetadataGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all addresses in a vault.
   * List Vault Addresses
   */
  async listVaultAddressesApiV1VaultsIdAddressesGetRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling listVaultAddressesApiV1VaultsIdAddressesGet.");
    }
    const queryParameters = {};
    if (requestParameters.sortBy) {
      queryParameters["sort_by"] = requestParameters.sortBy;
    }
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    if (requestParameters.addresses) {
      queryParameters["addresses"] = requestParameters.addresses;
    }
    if (requestParameters.addressTypes) {
      queryParameters["address_types"] = requestParameters.addressTypes;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/addresses`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultAddressesResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all addresses in a vault.
   * List Vault Addresses
   */
  async listVaultAddressesApiV1VaultsIdAddressesGet(requestParameters, initOverrides) {
    const response = await this.listVaultAddressesApiV1VaultsIdAddressesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all vaults in an organization.
   * List Vaults
   */
  async listVaultsApiV1VaultsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.sortBy) {
      queryParameters["sort_by"] = requestParameters.sortBy;
    }
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.vaultIds) {
      queryParameters["vault_ids"] = requestParameters.vaultIds;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    if (requestParameters.names) {
      queryParameters["names"] = requestParameters.names;
    }
    if (requestParameters.vaultTypes) {
      queryParameters["vault_types"] = requestParameters.vaultTypes;
    }
    if (requestParameters.vaultStates) {
      queryParameters["vault_states"] = requestParameters.vaultStates;
    }
    if (requestParameters.keysetIds) {
      queryParameters["keyset_ids"] = requestParameters.keysetIds;
    }
    if (requestParameters.keyHolderIds) {
      queryParameters["key_holder_ids"] = requestParameters.keyHolderIds;
    }
    if (requestParameters.vaultGroupIds) {
      queryParameters["vault_group_ids"] = requestParameters.vaultGroupIds;
    }
    if (requestParameters.excludeVaultGroupIds) {
      queryParameters["exclude_vault_group_ids"] = requestParameters.excludeVaultGroupIds;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all vaults in an organization.
   * List Vaults
   */
  async listVaultsApiV1VaultsGet(requestParameters = {}, initOverrides) {
    const response = await this.listVaultsApiV1VaultsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all vaults and their assets in an organization.
   * List Vaults With Assets
   */
  async listVaultsWithAssetsApiV1VaultsBalancesGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.includeAssetsInfo !== void 0) {
      queryParameters["include_assets_info"] = requestParameters.includeAssetsInfo;
    }
    if (requestParameters.page !== void 0) {
      queryParameters["page"] = requestParameters.page;
    }
    if (requestParameters.size !== void 0) {
      queryParameters["size"] = requestParameters.size;
    }
    if (requestParameters.vaultIds) {
      queryParameters["vault_ids"] = requestParameters.vaultIds;
    }
    if (requestParameters.chains) {
      queryParameters["chains"] = requestParameters.chains;
    }
    if (requestParameters.search !== void 0) {
      queryParameters["search"] = requestParameters.search;
    }
    if (requestParameters.vaultTypes) {
      queryParameters["vault_types"] = requestParameters.vaultTypes;
    }
    if (requestParameters.vaultStates) {
      queryParameters["vault_states"] = requestParameters.vaultStates;
    }
    if (requestParameters.utxoVaultSubTypes) {
      queryParameters["utxo_vault_sub_types"] = requestParameters.utxoVaultSubTypes;
    }
    if (requestParameters.keyHolderIds) {
      queryParameters["key_holder_ids"] = requestParameters.keyHolderIds;
    }
    if (requestParameters.hideEmpty !== void 0) {
      queryParameters["hide_empty"] = requestParameters.hideEmpty;
    }
    if (requestParameters.vaultGroupIds) {
      queryParameters["vault_group_ids"] = requestParameters.vaultGroupIds;
    }
    if (requestParameters.assetIds) {
      queryParameters["asset_ids"] = requestParameters.assetIds;
    }
    if (requestParameters.sortBy) {
      queryParameters["sort_by"] = requestParameters.sortBy;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/balances`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultsWithAssetsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all vaults and their assets in an organization.
   * List Vaults With Assets
   */
  async listVaultsWithAssetsApiV1VaultsBalancesGet(requestParameters = {}, initOverrides) {
    const response = await this.listVaultsWithAssetsApiV1VaultsBalancesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Rename an existing vault address.
   * Rename Vault Address
   */
  async renameVaultAddressApiV1VaultsAddressesIdNamePutRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling renameVaultAddressApiV1VaultsAddressesIdNamePut.");
    }
    if (requestParameters.renameVaultRequest === null || requestParameters.renameVaultRequest === void 0) {
      throw new RequiredError("renameVaultRequest", "Required parameter requestParameters.renameVaultRequest was null or undefined when calling renameVaultAddressApiV1VaultsAddressesIdNamePut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/addresses/{id}/name`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RenameVaultRequestToJSON(requestParameters.renameVaultRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Rename an existing vault address.
   * Rename Vault Address
   */
  async renameVaultAddressApiV1VaultsAddressesIdNamePut(requestParameters, initOverrides) {
    await this.renameVaultAddressApiV1VaultsAddressesIdNamePutRaw(requestParameters, initOverrides);
  }
  /**
   * Rename an existing vault.
   * Rename Vault
   */
  async renameVaultApiV1VaultsIdNamePutRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling renameVaultApiV1VaultsIdNamePut.");
    }
    if (requestParameters.renameVaultRequest === null || requestParameters.renameVaultRequest === void 0) {
      throw new RequiredError("renameVaultRequest", "Required parameter requestParameters.renameVaultRequest was null or undefined when calling renameVaultApiV1VaultsIdNamePut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/name`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RenameVaultRequestToJSON(requestParameters.renameVaultRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Rename an existing vault.
   * Rename Vault
   */
  async renameVaultApiV1VaultsIdNamePut(requestParameters, initOverrides) {
    await this.renameVaultApiV1VaultsIdNamePutRaw(requestParameters, initOverrides);
  }
  /**
   * Restore an archived vault.
   * Restore Vault
   */
  async restoreVaultApiV1VaultsIdRestorePostRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling restoreVaultApiV1VaultsIdRestorePost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/restore`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Restore an archived vault.
   * Restore Vault
   */
  async restoreVaultApiV1VaultsIdRestorePost(requestParameters, initOverrides) {
    await this.restoreVaultApiV1VaultsIdRestorePostRaw(requestParameters, initOverrides);
  }
  /**
   * Sync assets of a vault.
   * Sync Vault
   */
  async syncVaultApiV1VaultsIdSyncPutRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling syncVaultApiV1VaultsIdSyncPut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/sync`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Sync assets of a vault.
   * Sync Vault
   */
  async syncVaultApiV1VaultsIdSyncPut(requestParameters, initOverrides) {
    await this.syncVaultApiV1VaultsIdSyncPutRaw(requestParameters, initOverrides);
  }
  /**
   * Update vault metadata details.
   * Update Vault Metadata
   */
  async updateVaultMetadataApiV1VaultsIdMetadataPutRaw(requestParameters, initOverrides) {
    if (requestParameters.id === null || requestParameters.id === void 0) {
      throw new RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling updateVaultMetadataApiV1VaultsIdMetadataPut.");
    }
    if (requestParameters.updateVaultMetadataRequest === null || requestParameters.updateVaultMetadataRequest === void 0) {
      throw new RequiredError("updateVaultMetadataRequest", "Required parameter requestParameters.updateVaultMetadataRequest was null or undefined when calling updateVaultMetadataApiV1VaultsIdMetadataPut.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateVaultMetadataRequestToJSON(requestParameters.updateVaultMetadataRequest)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Update vault metadata details.
   * Update Vault Metadata
   */
  async updateVaultMetadataApiV1VaultsIdMetadataPut(requestParameters, initOverrides) {
    await this.updateVaultMetadataApiV1VaultsIdMetadataPutRaw(requestParameters, initOverrides);
  }
};

// src/api/api-client.ts
import {
  InternalRpcError,
  InvalidParamsRpcError,
  LimitExceededRpcError,
  ResourceNotFoundRpcError,
  UnauthorizedProviderError
} from "viem";

// src/constants.ts
var FORDEFI_API_BASE_URL_PROD = "https://api.fordefi.com";

// src/utils/wait-for.ts
var waitFor = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var waitForEmittedEvent = (eventEmitter) => {
  const waitForEvent = async (event, timeoutMs = 3e3) => {
    return new Promise((_resolve, _reject) => {
      let timeout;
      let resolve;
      const reject = () => {
        eventEmitter.removeListener(event, resolve);
        _reject(`Timeout waiting for event '${event}'`);
      };
      timeout = setTimeout(reject, timeoutMs);
      resolve = (...args) => {
        clearTimeout(timeout);
        _resolve(...args);
      };
      eventEmitter.on(event, resolve);
    });
  };
  return waitForEvent;
};

// src/utils/signatures.ts
import { bytesToHex } from "viem";

// src/utils/base64.ts
var base64ToBytes = (base64) => Buffer.from(base64, "base64");
var base64ToBinary = (base64) => base64ToBytes(base64).toString("binary");
var isValidBase64 = (maybeBase64) => {
  try {
    return base64ToBytes(maybeBase64).toString("base64") === maybeBase64;
  } catch {
    return false;
  }
};

// src/utils/signatures.ts
var base64SignatureToHex = (base64) => {
  const binaryString = base64ToBinary(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytesToHex(bytes);
};

// src/utils/time.ts
var ONE_SECOND_MS = 1e3;
var ONE_MINUTE_MS = 60 * ONE_SECOND_MS;
var ONE_HOUR_MS = 60 * ONE_MINUTE_MS;
var ONE_DAY_MS = 24 * ONE_HOUR_MS;
var getRenderTimeDurationParts = (durationMs) => {
  if (durationMs < ONE_MINUTE_MS) {
    return [durationMs / ONE_SECOND_MS, "s"];
  }
  if (durationMs < ONE_HOUR_MS) {
    return [durationMs / ONE_MINUTE_MS, "m"];
  }
  return [durationMs / ONE_HOUR_MS, "h"];
};
var renderTimeDuration = (durationMs) => {
  const [durationInUnits, units] = getRenderTimeDurationParts(durationMs);
  return [Number.isInteger(durationInUnits) ? durationInUnits : durationInUnits.toFixed(1), units].join("");
};

// src/api/request-body-sign.ts
import * as crypto from "crypto";
var dashes = "-----";
var pemBeginClause = `${dashes}BEGIN EC PRIVATE KEY${dashes}`;
var pemEndClause = `${dashes}END EC PRIVATE KEY${dashes}`;
var endpointRequiresSignature = "/api/v1/transactions";
var signApiRequestBody = async (body, pem, date = /* @__PURE__ */ new Date()) => {
  const timestamp = date.getTime().toString();
  const payloadToSign = [endpointRequiresSignature, timestamp, JSON.stringify(body)].join("|");
  const privateKey = crypto.createPrivateKey(toValidPem(pem));
  const sign = crypto.createSign("SHA256").update(payloadToSign, "utf8").end();
  const signature = sign.sign(privateKey, "base64");
  return {
    timestamp,
    signature
  };
};
var toValidPem = (pem) => {
  const base64 = pem.replace(pemBeginClause, "").replace(pemEndClause, "").replace(/\s/g, "");
  if (base64.includes(dashes)) {
    throw new Error(
      `Invalid PEM format: the header and footer indicate the key was not generated properly. Expected header to be ${pemBeginClause} and footer to be ${pemEndClause}.`
    );
  }
  if (!base64 || !isValidBase64(base64)) {
    throw new Error("Invalid PEM format: expected base64 encoded string.");
  }
  return [pemBeginClause, base64, pemEndClause].join("\n");
};

// src/api/headers.ts
var middlewareAddRequestSigningHeaders = (apiPayloadSignKeyBase64) => async (context) => {
  const signedBodyParams = await signApiRequestBody(context.init.body, apiPayloadSignKeyBase64);
  return {
    headers: {
      ...context.init.headers,
      ...signatureToHeaders(signedBodyParams)
    }
  };
};
var signatureToHeaders = ({ timestamp, signature }) => ({
  ["X-Timestamp" /* Timestamp */]: timestamp,
  ["X-Signature" /* Signature */]: signature
});
var getStaticHeaders = () => ({
  ["User-Agent" /* UserAgent */]: "Fordefi Web3 Provider"
});

// src/api/api-client.ts
var httpStatusToErrorClass = {
  [400 /* BadRequest */]: InvalidParamsRpcError,
  [401 /* Unauthorized */]: UnauthorizedProviderError,
  [403 /* Forbidden */]: UnauthorizedProviderError,
  [404 /* NotFound */]: ResourceNotFoundRpcError,
  [503 /* ServiceUnavailable */]: InternalRpcError,
  [429 /* TooManyRequests */]: LimitExceededRpcError,
  [500 /* InternalServerError */]: InternalRpcError
};
var ApiClient = class {
  constructor(providerConfig) {
    const { apiBaseUrl, apiUserToken } = providerConfig;
    const config = new Configuration({
      basePath: apiBaseUrl ?? FORDEFI_API_BASE_URL_PROD,
      accessToken: apiUserToken,
      headers: getStaticHeaders(),
      middleware: [
        {
          post: async (context) => {
            if (context.response?.status < 400) {
              return;
            }
            const payload = await context.response?.clone().json().catch(() => "Failed to parse error response body").then(JSON.stringify);
            const status = context.response?.status;
            const error = new Error(payload);
            const ErrorClass = httpStatusToErrorClass[status] ?? InternalRpcError;
            throw new ErrorClass(error);
          }
        }
      ]
    });
    this.vaults = new VaultsApi(config);
    this.blockchains = new BlockchainsApi(config);
    this.transactions = new TransactionsApi(config);
  }
};

// src/utils/transactions.ts
import { hexToBigInt, InternalRpcError as InternalRpcError2, InvalidParamsRpcError as InvalidParamsRpcError2, isAddress, isAddressEqual, isHex } from "viem";
var toFordefiTransactionNumericValue = (value) => {
  if (value === void 0) {
    throw new Error("value cannot be undefined");
  }
  if (typeof value === "string") {
    if (value.trim() === "") {
      throw new Error("value cannot be an empty string");
    }
    if (value.startsWith("-")) {
      throw new Error("value provided as a string cannot be negative");
    }
    if (isHex(value, { strict: true })) {
      return hexToBigInt(value).toString();
    }
    if (value.match(/^\d+$/)) {
      return value;
    }
    throw new Error("value provided as a string must be a valid decimal or hex string");
  }
  if (typeof value === "number") {
    if (isNaN(value)) {
      throw new Error("value is NaN");
    }
    if (!Number.isSafeInteger(value)) {
      throw new Error("value of type number is not a safe integer, use a bigint instead");
    }
    if (value < 0) {
      throw new Error("value must be a non-negative number");
    }
    return BigInt(value).toString();
  }
  if (typeof value === "bigint") {
    if (value < 0) {
      throw new Error("value must be a non-negative number");
    }
    return value.toString();
  }
  throw new Error("value must be a valid number");
};
var parseTransactionRequestValueField = (value) => {
  if (value === void 0) {
    return "0";
  }
  try {
    return toFordefiTransactionNumericValue(value);
  } catch (parseError) {
    throw new InvalidParamsRpcError2(new Error(`invalid "value": ${parseError.message}`));
  }
};
var parseTransactionRequestGasField = (fieldName, value) => {
  try {
    return toFordefiTransactionNumericValue(value);
  } catch (parseError) {
    throw new InvalidParamsRpcError2(new Error(`invalid ${fieldName}: ${parseError.message}`));
  }
};
var buildSignTransactionRequest = (vaultId, chainId, messageType, rawData) => ({
  type: CreateEvmMessageRequestTypeEnum.evmMessage,
  signerType: SignerType.apiSigner,
  vaultId,
  details: {
    type: messageType,
    chain: chainId,
    rawData
  }
});
var toFordefiEvmGas = ({
  maxPriorityFeePerGas,
  maxFeePerGas,
  gasPrice,
  gas
}) => {
  const gasLimit = gas !== void 0 && gas !== null ? parseTransactionRequestGasField("gas", gas) : void 0;
  if (maxPriorityFeePerGas !== void 0 && maxFeePerGas !== void 0) {
    return {
      type: CustomGasRequestTypeEnum.custom,
      gasLimit,
      details: {
        type: DynamicGasRequestTypeEnum.dynamic,
        maxPriorityFeePerGas: parseTransactionRequestGasField("maxPriorityFeePerGas", maxPriorityFeePerGas),
        maxFeePerGas: parseTransactionRequestGasField("maxFeePerGas", maxFeePerGas)
      }
    };
  }
  if (gasPrice !== void 0) {
    return {
      type: CustomGasRequestTypeEnum.custom,
      gasLimit,
      details: {
        type: LegacyGasTypeEnum.legacy,
        price: parseTransactionRequestGasField("gasPrice", gasPrice)
      }
    };
  }
  return {
    type: GasPriorityRequestTypeEnum.priority,
    gasLimit,
    priorityLevel: GasPriorityLevelRequest.medium
  };
};
var buildEvmRawTransactionRequest = ({
  transaction,
  chain,
  vault,
  pushMode,
  skipPrediction = true
}) => {
  const { value, from, to, data } = transaction;
  if (from && !isAddressEqual(from, vault.address)) {
    throw new InvalidParamsRpcError2(
      new Error('Transaction "from" does not match the address managed by this provider')
    );
  }
  if (to && !isAddress(to)) {
    throw new InvalidParamsRpcError2(new Error('Transaction "to" is not a valid address'));
  }
  return {
    type: CreateEvmTransactionRequestTypeEnum.evmTransaction,
    vaultId: vault.id,
    signerType: SignerType.apiSigner,
    details: {
      type: CreateEvmRawTransactionRequestTypeEnum.evmRawTransaction,
      gas: toFordefiEvmGas(transaction),
      skipPrediction,
      pushMode,
      chain: chain.chainId,
      value: parseTransactionRequestValueField(value),
      to: to ?? void 0,
      data: data ? {
        type: EvmDataRequestHexTypeEnum.hex,
        hexData: data
      } : void 0
    }
  };
};
var waitForTransactionState = async ({
  transaction: { id: transactionId },
  desiredState,
  apiClient,
  timeoutDurationMs,
  pollingIntervalMs
}) => {
  console.debug(
    `waiting for transaction state change to '${desiredState}' with timeout of ${renderTimeDuration(timeoutDurationMs)}`
  );
  let attemptStartTimeMs = Date.now();
  const timeoutTimeMs = attemptStartTimeMs + timeoutDurationMs;
  while ((attemptStartTimeMs = Date.now()) < timeoutTimeMs) {
    const transaction = await apiClient.transactions.getTransactionApiV1TransactionsIdGet({
      id: transactionId
    });
    if (isErrorState(transaction.state)) {
      throw new InternalRpcError2(new Error(`Transaction failed with state '${transaction.state}'`));
    }
    if (didStateAlreadyOccur(transaction.state, desiredState)) {
      console.debug(
        `transaction reached desired state '${desiredState}'${desiredState !== transaction.state ? ` and is now '${transaction.state}'` : ""}`
      );
      return transaction;
    }
    console.debug(
      `[${(/* @__PURE__ */ new Date()).toISOString()}] transaction state is '${transaction.state}', waiting for '${desiredState}'...`
    );
    const timeSinceAttemptStartMs = Date.now() - attemptStartTimeMs;
    const remainingWaitTimeMs = pollingIntervalMs - timeSinceAttemptStartMs;
    if (remainingWaitTimeMs > 0) {
      await waitFor(remainingWaitTimeMs);
    }
  }
  throw new InternalRpcError2(new Error(`Timeout while waiting for transaction status to change to '${desiredState}'`));
};
var parseTypedDataParams = (params) => {
  const [_maybeFromAddress, _maybeTypedData] = params;
  const [fromAddress, _typedData] = isAddress(_maybeFromAddress) ? [_maybeFromAddress, _maybeTypedData] : [_maybeTypedData, _maybeFromAddress];
  const typedData = typeof _typedData === "string" ? _typedData : JSON.stringify(_typedData);
  return { typedData, fromAddress };
};
var orderedTransactionStates = [
  EvmTransactionState.waitingForApproval,
  EvmTransactionState.approved,
  EvmTransactionState.signed,
  EvmTransactionState.queued,
  EvmTransactionState.pushedToBlockchain,
  EvmTransactionState.stuck,
  EvmTransactionState.mined,
  EvmTransactionState.completed
];
var errorTransactionStates = [
  EvmTransactionState.errorSigning,
  EvmTransactionState.errorPushingToBlockchain,
  EvmTransactionState.aborted,
  EvmTransactionState.stuck,
  EvmTransactionState.cancelled
];
var didStateAlreadyOccur = (currentState, desiredState) => orderedTransactionStates.indexOf(currentState) >= orderedTransactionStates.indexOf(desiredState);
var isErrorState = (state) => errorTransactionStates.includes(state);

// src/utils/types.ts
var assertUnreachable = (x) => {
  throw new Error("Unreachable");
};

// src/provider/provider.types.ts
var fordefiMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_accounts",
  "eth_requestAccounts",
  "eth_chainId",
  "personal_sign",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4"
];
var isFordefiMethod = (args) => {
  return fordefiMethods.includes(args.method);
};

// src/provider/provider.ts
var FordefiWeb3Provider = class {
  constructor(config) {
    this.config = config;
    this.apiClient = new ApiClient(config);
    const eventEmitter = new EventEmitter();
    this.on = eventEmitter.on.bind(eventEmitter);
    this.removeListener = eventEmitter.removeListener.bind(eventEmitter);
    this.eventEmitter = eventEmitter;
    this.waitForEmittedEvent = waitForEmittedEvent(eventEmitter);
    this.status = "disconnected";
    this.connect().catch();
  }
  /**
   * Handles a JSON-RPC request
   *
   * @param args JSON-RPC request payload
   * @returns A promise with a response
   *
   * @throws RpcError with error codes defined in {@link RpcErrorCode} and {@link ProviderRpcErrorCode}
   */
  async request(args) {
    let result;
    if (isFordefiMethod(args)) {
      switch (args.method) {
        // EIP-1474
        case "eth_sendTransaction":
          result = this.ethSendTransaction(args);
          break;
        case "eth_signTransaction":
          result = this.ethSignTransaction(args);
          break;
        case "eth_accounts":
          result = this.ethAccounts();
          break;
        // EIP-1102
        case "eth_requestAccounts":
          result = this.ethAccounts();
          break;
        // EIP-695
        case "eth_chainId":
          result = this.ethChainId();
          break;
        // EIP-191
        case "personal_sign":
          result = this.personalSign(args);
          break;
        // EIP-712
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          result = this.ethSignTypedData(args);
          break;
        default:
          assertUnreachable(args);
      }
    } else {
      result = this.jsonRpcHttpRequestFn(args);
    }
    return result;
  }
  jsonRpcHttpRequestFn(args) {
    if (!this.config.rpcUrl) {
      throw new UnsupportedProviderMethodError(
        new Error(
          "RPC method not supported by Fordefi provider. Construct the provider with `rpcUrl` to fallback to an external JSON RPC provider."
        )
      );
    }
    return http(this.config.rpcUrl)({}).request(args);
  }
  async ethChainId() {
    if (this.chain) {
      return numberToHex(this.chain.chainId);
    }
    const { chains } = await this.apiClient.blockchains.listChainsApiV1BlockchainsGet({ chainTypes: [ChainType.evm] });
    const chain = chains.find((chain2) => {
      const matchedProperty = typeof this.config.chainId === "string" ? "uniqueId" : "chainId";
      return chain2[matchedProperty] === this.config.chainId;
    });
    if (!chain) {
      throw new InvalidParamsRpcError3(new Error(`Unsupported chain id ${this.config.chainId}`));
    }
    this.chain = chain;
    const chainId = numberToHex(chain.chainId);
    this.eventEmitter.emit("chainChanged", chainId);
    return chainId;
  }
  async ethAccounts() {
    if (this.vault) {
      return [this.vault.address];
    }
    const response = await this.apiClient.vaults.listVaultsApiV1VaultsGet({
      search: this.config.address,
      vaultTypes: [VaultType.evm]
    });
    const { vaults } = response;
    const vault = vaults[0];
    if (!vault) {
      throw new InvalidInputRpcError(new Error(`Vault with address ${this.config.address} not found`));
    }
    this.vault = vault;
    const accounts = [vault.address];
    this.eventEmitter.emit("accountsChanged", accounts);
    return accounts;
  }
  async ethSendTransaction({ params }) {
    const [transaction] = params;
    const { vault, chain } = this._getFordefiChainVault();
    const { hash } = await this._invokeCreateTransaction(
      buildEvmRawTransactionRequest({
        transaction,
        chain,
        vault,
        pushMode: PushMode.auto,
        skipPrediction: this.config.skipPrediction
      })
    );
    if (!hash || !isHex2(hash)) {
      throw new InternalRpcError3(new Error("Missing transaction hash in create transaction response"));
    }
    return hash;
  }
  async ethSignTransaction({ params }) {
    const [transaction] = params;
    const { vault, chain } = this._getFordefiChainVault();
    const { rawTransaction } = await this._invokeCreateTransaction(
      buildEvmRawTransactionRequest({
        transaction,
        chain,
        vault,
        pushMode: PushMode.manual,
        skipPrediction: this.config.skipPrediction
      })
    );
    if (!rawTransaction) {
      throw new InternalRpcError3(new Error("Missing raw transaction in create transaction response"));
    }
    return rawTransaction;
  }
  async personalSign({ params }) {
    const [rawData, signingAddress] = params;
    const { chain, vault } = this._getFordefiChainVault();
    if (!isAddressEqual2(signingAddress, vault.address)) {
      throw new InvalidParamsRpcError3(
        new Error(`Address ${signingAddress} does not match this provider's managed address ${vault.address}.`)
      );
    }
    return this._createEvmMessageTransaction(
      buildSignTransactionRequest(
        vault.id,
        chain.chainId,
        CreateEvmPersonalMessageRequestTypeEnum.personalMessageType,
        rawData
      )
    );
  }
  async ethSignTypedData({
    params
  }) {
    const { typedData, fromAddress } = parseTypedDataParams(params);
    const { chain, vault } = this._getFordefiChainVault();
    if (!isAddressEqual2(fromAddress, vault.address)) {
      throw new InvalidParamsRpcError3(
        new Error(`Address ${fromAddress} does not match given provider's address ${vault.address}`)
      );
    }
    return this._createEvmMessageTransaction(
      buildSignTransactionRequest(
        vault.id,
        chain.chainId,
        CreateEvmTypedMessageRequestTypeEnum.typedMessageType,
        typedData
      )
    );
  }
  async _createEvmMessageTransaction(createTransactionRequest) {
    const { signatures } = await this._invokeCreateTransaction(createTransactionRequest);
    if (signatures.length === 0) {
      throw new InternalRpcError3(new Error("No signatures found in create transaction response"));
    }
    return base64SignatureToHex(signatures[0].data);
  }
  async _invokeCreateTransaction(createTransactionRequest) {
    const transaction = await this.apiClient.transactions.createTransactionApiV1TransactionsPost(
      { createTransactionRequest },
      middlewareAddRequestSigningHeaders(this.config.apiPayloadSignKey)
    );
    if (transaction.type !== createTransactionRequest.type) {
      throw new InternalRpcError3(
        new Error(
          `Created transaction has unexpected type ${transaction.type} while transaction type in the request was ${createTransactionRequest.type}`
        )
      );
    }
    return waitForTransactionState({
      transaction,
      desiredState: EvmTransactionState.signed,
      apiClient: this.apiClient,
      timeoutDurationMs: ONE_DAY_MS,
      pollingIntervalMs: 5 * ONE_SECOND_MS
    });
  }
  _getFordefiChainVault() {
    this._throwIfNotConnected();
    if (!this.chain || !this.vault) {
      throw new InternalRpcError3(new Error("Unexpected state: provider is connected but chain or vault is missing"));
    }
    return { chain: this.chain, vault: this.vault };
  }
  _throwIfNotConnected() {
    if (this.getStatus() !== "connected") {
      throw this._onDisconnect();
    }
  }
  /**
   * Connects the provider to Fordefi and emits a 'connect' event.
   * - If already connected, it does nothing.
   * - If connecting, waits for the connection to be established.
   *
   * @returns A promise that resolves once connected.
   */
  async connect() {
    if (this.status === "connected") {
      return Promise.resolve();
    }
    if (this.status === "connecting") {
      await this.waitForEmittedEvent("connect");
    }
    this.status = "connecting";
    const re = await this.request({ method: "eth_accounts" });
    await Promise.all([this.request({ method: "eth_accounts" }), this.request({ method: "eth_chainId" })]).then(
      ([_address, chainId]) => {
        if (this.status === "connecting") {
          this.status = "connected";
          this.eventEmitter.emit("connect", { chainId });
        }
      }
    );
  }
  /**
   * Disconnects the provider and emits a 'disconnect' event.
   */
  disconnect() {
    if (this.status === "disconnected") {
      return;
    }
    this.chain = void 0;
    this.vault = void 0;
    this.status = "disconnected";
    this._onDisconnect();
  }
  _onDisconnect() {
    const error = new ProviderDisconnectedError(new Error("Provider got disconnected"));
    this.eventEmitter.emit("disconnect", error);
    return error;
  }
  /**
   * Returns the current status of the provider.
   *
   * @returns 'connected' if the provider is connected, 'connecting' if trying to connect, 'disconnected' otherwise.
   */
  getStatus() {
    return this.status;
  }
};

// src/index.ts
var EvmChainId2 = EvmChainId;
var EvmChainUniqueId2 = EvmChainUniqueId;
export {
  EIP1193EventMap,
  EvmChainId2 as EvmChainId,
  EvmChainUniqueId2 as EvmChainUniqueId,
  FordefiWeb3Provider
};
